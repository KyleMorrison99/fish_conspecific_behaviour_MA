---
title: "The impacts of pesticide exposure on fish conspecific behavioural interactions: a systematic review and meta-analysis"
author: Kyle Morrison, Aneesh Bose, Rhiannon Eastment, Jack Manera, Gabriel Melhado, Marcus
  Michelangeli, Shiho Ozeki, Bob Wong, Yefeng Yang, Malgorzata Lagisz, Shinichi Nakagawa
date: "latest update: `r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    code_download: true
    theme: flatly   # Options: cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, yeti
    highlight: monochrome  # Options: default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, textmate
editor_options: 
  chunk_output_type: console

---
```{r setup, include = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE,
  echo=TRUE
)
```

# **Load packages and data**

## *Load packages*
```{r}
rm(list = ls())

pacman::p_load(tidyverse,
               here,
               kableExtra,
               magrittr, 
               patchwork,
               metafor,
               metagear,
               ape,
               rotl,
               orchaRd,
               clubSandwich,
               MuMIn,
               ggsankey)

```

## *Load Data*
```{r}
data <- read_csv(here("data", "fish_conspecific_behaviour_ma_data.csv"), skip = 0)

# Format ID variables as characters
data <- mutate_at(data, 
                  vars(study_id, 
                       exp_id, 
                       exp2_id, 
                       assay_id, 
                       assay2_id), 
                       as.character)
# Table of the dataset
 kable(data, "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "800px")


# Summary of the data set
kable(summary(data), "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "500px")
```


# **Data exploration and reporting of methodological items**
## *Figure 1b & 1c*
b) A bubble plot showing the number of effect sizes of each pesticide class per conspecific interaction behaviour described
c) A bar chart showing the total number of effect sizes per species
```{r,fig.width=8, fig.height=13}
# Summarize data by grouping on pesticide chemical class and behavior measured, then count entries.
pc_cb_summary <- data %>% 
  group_by(pesticide_chemical_class, behaviour_measured_standardised) %>% 
  summarise(n = n(), .groups = "drop")

# Determine the top 9 pesticide classes based on the number of records.
top_pesticide_class <- pc_cb_summary %>%
  group_by(pesticide_chemical_class) %>%
  summarise(total_count = sum(n)) %>%
  top_n(9, total_count) %>%
  pull(pesticide_chemical_class)

# Adjust category names to 'Other pesticide classes' for those pesticide classes not in the top 9
pc_cb_summary_filtered <- pc_cb_summary %>%
  mutate(pesticide_chemical_class = ifelse(pesticide_chemical_class %in% top_pesticide_class,
                                           pesticide_chemical_class,
                                           "Other Pesticide Classes")) %>%
  group_by(pesticide_chemical_class, behaviour_measured_standardised) %>%
  summarise(n = sum(n), .groups = "drop")

# Create the bubble plot
behaviour_pesticide_class_bubble_plot <- pc_cb_summary_filtered %>%
   ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(pesticide_chemical_class), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) +
  scale_size_continuous(range = c(5, 20)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"))  +
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the total number of effect sizes",
       x = "Behaviour Measured",
       y = "Pesticide Chemical Class",
       tag = "B")

# Group data by species, count entries, and drop groups post-summary.
sp_summary <- data %>% 
  group_by(species_english) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate proportion and percentage of total counts for each species.
species_pct <- sp_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create the bar plot
species_effect_size_count_bar_plot <- sp_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(species_english), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  geom_text(aes(label = ifelse(n < 9, "", n), x = n / 2, y = reorder(str_to_title(species_english), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = species_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sp_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total number of effect size estimates",
       y = "Species",
       tag = "C")

# Combine both plots into a single figure.
main_text_figure_1 <- behaviour_pesticide_class_bubble_plot / species_effect_size_count_bar_plot

print(main_text_figure_1)
# ggsave(here("figures", "main_text_figure_1.pdf"), width = 8, height = 13, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "main_text_figure_1.jpg"), width = 8, height = 13, units = "cm", scale = 2, dpi = 800)
```


## *Figure sx*
A bubble plot showing the number of effect sizes of each species per conspecific interaction behaviour described
```{r,fig.width=8, fig.height=6}
# Group data by species, count entries, and drop groups post-summary.
species_summary <- data %>%
  group_by(species_english, behaviour_measured_standardised) %>%
  summarise(
    n = n(),
    pesticide_chemical_class = first(pesticide_chemical_class),
    .groups = "drop"
  )

# Determine the top 20 species based on the number of records.
top_species <- species_summary %>%
  group_by(species_english, behaviour_measured_standardised) %>%
  summarise(total_count = sum(n), .groups = "drop") %>%
  top_n(20, total_count) %>%
  pull(species_english)

# Adjust category names to 'Other' for all but the top species, then re-summarize.
# species_summary_filtered <- species_summary %>%
#   mutate(species_english = ifelse(species_english %in% top_species,
#                                   species_english,
#                                   "Other Species")) %>%
#   group_by(species_english, behaviour_measured_standardised) %>%
#   summarise(n = sum(n), .groups = "drop")

# Create the bubble plot the behaviours assessed per species (number of effect size as count)
behaviour_species_bubble_plot <- species_summary %>% # can add _filtered if needed
  ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(species_english), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  scale_size_continuous(range = c(8, 25)) +
  theme_bw() +
  guides(size = "none") +
theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) + 
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the number of effect sizes",
       x = "Behaviour Measured",
       y = "Species") +
  scale_color_brewer(palette = "Dark2", name = "Chemical Class")

print(behaviour_species_bubble_plot)

# ggsave(here("figures", "behaviour_species_bubble_plot.pdf"), width = 8, height = 6, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "behaviour_species_bubble_plot.jpg"), width = 8, height = 6, units = "cm", scale = 2, dpi = 800)
```


## *Figure sx*
A bar chart showing the sex of fish used in the literature
```{r,fig.width=10, fig.height=5}
# Group data by 'sex of fish' and count entries, then drop grouping for further analysis.
sex_summary <- data %>% 
  group_by(sex) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate proportions and percentages of total studies for each sex.
sex_pct <- sex_summary %>% 
  mutate(proportion = n / sum(n),  
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies per sex, with annotations for counts and percentages.
fish_sex_study_count_bar_plot <- sex_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(sex), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(sex), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = sex_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sex_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of effect sizes",
       y = "Sex of fish")

print(fish_sex_study_count_bar_plot)

# ggsave(here("figures", "fish_sex_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "fish_sex_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar chart showing the reporting of the source of fish used in the literature
```{r,fig.width=10, fig.height=5}
# Extracts unique records from the dataset based on 'study_id', retaining all other associated data.
data_study <- data %>%
  distinct(study_id, .keep_all = TRUE) 

# Groups the filtered data by 'source of fish' and counts the number of studies per source, removing grouping afterwards.
source_summary <- data %>% 
  group_by(source) %>% 
  summarise(n = n(), .groups = "drop")

# Calculates the proportion and percentage of total studies for each source of fish.
source_pct <- source_summary %>% 
  mutate(proportion = n / sum(n),  # number of studies
         percentage = proportion * 100)

# Create the bar plot for the source of fish study count
fish_source_study_count_bar_plot <- source_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(source), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(source), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = source_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(source_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of studies",
       y = "Source of fish") 

print(fish_source_study_count_bar_plot)

# ggsave(here("figures", "fish_source_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "fish_source_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```


## *Figure sx*
A bubble plot showing the number of effect sizes of each pesticide per conspecific interaction behaviour described
```{r,fig.width=8, fig.height=8}
# Group data by species, count entries, and drop groups post-summary.
p_cb_summary <- data %>%
  group_by(pesticide, behaviour_measured_standardised) %>%
  summarise(
    n = n(),
    pesticide_chemical_class = first(pesticide_chemical_class),
    .groups = "drop"
  )
# Determine the top 8 pesticide classes based on the number of records.
top_pesticides <- p_cb_summary %>%
  group_by(pesticide, behaviour_measured_standardised) %>%
  summarise(total_count = sum(n), .groups = "drop") %>%
  top_n(20, total_count) %>%
  pull(pesticide)

# Adjust category names to 'Other Pesticides' for all but the top pesticide, then re-summarize.
# p_cb_summary_filtered <- p_cb_summary %>%
# mutate(pesticide = ifelse(pesticide %in% top_pesticides,
#                                          pesticide,
#                                          "Other Pesticides")) %>%
#  group_by(pesticide, behaviour_measured_standardised) %>%
#  summarise(n = sum(n), .groups = "drop")


# Create the bubble plot for the behaviours assessed per pesticide (effect size as count)
behaviour_pesticide_bubble_plot <- p_cb_summary %>% # can add _filtered if needed
   ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(pesticide), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[5]) +
  scale_size_continuous(range = c(4, 20)) +
  theme_bw() +
  guides(size = "none") +
theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the number of effect sizes",
       x = "Behaviour Measured",
       y = "Pesticide Chemical Class") +
      scale_y_discrete(labels = function(x) ifelse(x %in% c("Ddt", "Dca", "Dcpmu"), toupper(x), x))

print(behaviour_pesticide_bubble_plot)

# ggsave(here("figures", "behaviour_pesticide_bubble_plot.pdf"), width = 8, height = 12, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "behaviour_pesticide_bubble_plot.jpg"), width = 8, height = 12, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar plot showing the control solvents used in the literature
```{r,fig.width=10, fig.height=5}
# Group data by 'control solvent' and count entries, then drop the group structure for further analysis.
solvent_summary <- data %>% 
  group_by(control_solvent) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate the proportion and percentage of total studies for each control solvent.
solvent_pct <- solvent_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies per control solvent, annotated with counts and percentages.
control_solvent_study_count_bar_plot <- solvent_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(control_solvent), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(control_solvent), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = solvent_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(solvent_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of studies",
       y = "Control Solvent") +
  scale_y_discrete(labels = function(x) ifelse(x == "Dmso", toupper(x), ifelse(x == "Dtnb", toupper(x), x)))

print(control_solvent_study_count_bar_plot)

# ggsave(here("figures", "control_solvent_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "control_solvent_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A box and violin plot showing the distribution of pesticide dosages used in the literature
```{r}
# making dosages consistent for dosage comparisons
data_dosage <- data %>%
  filter(dosage != "not reported") %>% 
filter(dosage_unit != "not reported") %>% 
filter(!dosage_unit %in% c("nm", "um", "nM")) %>%
  mutate(dosage = as.numeric(dosage),
         dosage_unit = as.character(dosage_unit),
         dosage_unit_consistent = case_when(
           dosage_unit == "mg/L" ~ "ug/L", 
           dosage_unit == "ng/L" ~ "ug/L",
           dosage_unit == "g/L" ~ "ug/L",
           dosage_unit == "ppb" ~ "ug/L", 
           dosage_unit == "ppm" ~ "ug/L", 
           TRUE ~ dosage_unit),
         dosage_convert_ugL = case_when(
           dosage_unit == "mg/L" ~ dosage * 1000,
           dosage_unit == "ng/L" ~ dosage / 1000,
           dosage_unit == "g/L" ~ dosage/1000000,
           dosage_unit == "ppm" ~ dosage*1000, 
           TRUE ~ dosage))

# Summary table for the dosage converted
summary_data_dosage <- summary(data_dosage$dosage_convert_ugL)

# Filter the data for dosage_convert_ugL less than 5000
filtered_data_dosage <- data_dosage %>%
  filter(dosage_convert_ugL < 3000)

# Create the violin plot
pesticide_dosage_violin_plot <- ggplot(filtered_data_dosage, aes(y = dosage_unit_consistent, x = dosage_convert_ugL)) +
    geom_violin(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.4, color = NA, trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white", color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], outlier.shape = NA) +
  geom_jitter(width = 0.3, height = 0.09, color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.8) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_blank(),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Plot filtered for less than 3000 ug/L\nMedian = 12, 1st Quartile = 1, 3rd Quartile = 500",
       y = "Dosage Unit [ug/L]")

print(pesticide_dosage_violin_plot)

# ggsave(here("figures", "pesticide_dosage_violin_plot.pdf"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "pesticide_dosage_violin_plot.jpg"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```


## *Figure sx*
A box and violin plot the distribution of durations of pesticide exposure 
```{r}
data_duration <- data %>% 
  filter(!is.na(duration), duration != "not reported") %>%
  mutate(duration = as.numeric(duration),
         duration_unit = as.character(duration_unit),
           duration_unit_consistent = case_when(
          duration_unit == "minutes" ~ "hours",
          duration_unit == "days" ~ "hours",
          duration_unit == "weeks" ~ "hours",
           TRUE ~ duration_unit),
 duration_convert = case_when(
    duration_unit == "minutes" ~ duration/ 60, 
    duration_unit == "days" ~ duration*24, 
    duration_unit == "weeks" ~ duration*168,
    TRUE ~ duration))

summary(data_duration$duration_convert)

# Create the violin plot for duration
pesticide_duration_violin_plot <- ggplot(data_duration, aes(y = duration_unit_consistent, x = duration_convert)) +
  geom_violin(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.4, color = NA, trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white", color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], outlier.shape = NA) +
  geom_jitter(width = 0.3, height = 0.09, color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.8) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_blank(),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Median = 336, 1st Quartile = 96, 3rd Quartile = 960",
       y = "Duration [hours]")

print(pesticide_duration_violin_plot)

# ggsave(here("figures", "pesticide_duration_violin_plot.pdf"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "pesticide_duration_violin_plot.jpg"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar plot showing the behavioural assays used to quantify soliality in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "sociality" in behaviour_measure_standardised
sociality_data <- data %>% 
  filter(grepl("sociality", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardized and count occurrences
sociality_assay_summary <- sociality_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each control solvent
sociality_assay_pct <- sociality_assay_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on aggression, annotated with counts and percentages.
sociality_assay_effect_size_count_bar_plot <- sociality_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[5]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = sociality_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sociality_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Sociality Assay")

print(sociality_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "sociality_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "sociality_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar plot showing the behavioural assays used to quantify aggression in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "aggression" in behaviour_measure_standardised
aggression_data <- data %>% 
  filter(grepl("aggression", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
aggression_assay_summary <- aggression_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
aggression_assay_pct <- aggression_assay_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on aggression, annotated with counts and percentages.
aggression_assay_effect_size_count_bar_plot <- aggression_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[6]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = aggression_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(aggression_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Aggression Assay")

print(aggression_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "aggression_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "aggression_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar plot showing the behavioural assays used to quantify courtship in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "courtship" in behaviour_measure_standardised
courtship_data <- data %>% 
  filter(grepl("courtship", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
courtship_assay_summary <- courtship_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
courtship_assay_pct <- courtship_assay_summary %>% 
  mutate(proportion = n / sum(n), # Adjust total number of observations
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on courtship, annotated with counts and percentages.
courtship_assay_effect_size_count_bar_plot <- courtship_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[6]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = courtship_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(courtship_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Courtship Assay")

print(courtship_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "courtship_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "courtship_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
A bar plot showing the behavioural assays used to quantify collective behaviour (i.e., behaviours measure at collective level) in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "collective behaviour" in behaviour_measure_standardised
collective_behaviour_data <- data %>% 
  filter(grepl("collective behaviour", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
collective_behaviour_assay_summary <- collective_behaviour_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
collective_behaviour_assay_pct <- collective_behaviour_assay_summary %>% 
  mutate(proportion = n / sum(n), # Adjust total number of observations
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on collective behaviour, annotated with counts and percentages.
collective_behaviour_assay_effect_size_count_bar_plot <- collective_behaviour_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_sentence(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[7]) +
  geom_text(aes(label = ifelse(n < 9, "", n), x = n / 2, y = reorder(str_to_sentence(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = collective_behaviour_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(collective_behaviour_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Collective Behaviour Assay")

print(collective_behaviour_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "collective_behaviour_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "collective_behaviour_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## *Figure sx*
Visual representation of the characteristics of the primary studies included in the dataset. The vertical bars indicate key categorical variables. The widths of the vertical bars indicate the numbers of effect sizes represented by each level of the categorical variable. The flow lines between vertical bars indicate the connections and overlaps of different levels of the categorical variables. 
```{r}
# Select relevant columns and replace NA values with "Not Reported"
data_sankey <- data %>%
  select(c(behaviour_measured_standardised, 
           behavioural_assay_standardised2, 
           pesticide_chemical_class, 
           control_solvent, 
           species_english, 
           sex, 
           source)) %>%
  mutate(across(c(behaviour_measured_standardised, 
                  behavioural_assay_standardised2, 
                  pesticide_chemical_class,
                  control_solvent, 
                  species_english, 
                  sex, 
                  source), 
                ~ replace_na(., "Not Reported")))

# Transform data into a long format for the Sankey plot
sankey_df <- data_sankey %>%
  ggsankey::make_long(behaviour_measured_standardised, 
                      behavioural_assay_standardised2, 
                      pesticide_chemical_class,
                      control_solvent, 
                      species_english, 
                      sex, 
                      source)

# Create the Sankey plot
ggplot(sankey_df, aes(x = x, next_x = next_x, 
                      node = node, 
                      next_node = next_node, 
                      fill = factor(node), 
                      label = node)) +
  geom_sankey(flow.alpha = .6, node.color = "gray30") +
  geom_sankey_label(size = 3, color = "white", fill = "gray40") +
  scale_fill_viridis_d() +
  scale_x_discrete(labels = c("Behaviour Measured", "Assay type", "Pesticide chemical class", 
                              "Control Solvent", "Species", "Sex", "Source"), 
                   position = "top") +
  theme_sankey(base_size = 10) +
  labs(x = NULL) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = .5),
        axis.text.x = element_text(color = "black", size = 9))
```

# **Calculate effect size estimates & dependency**
## *Find SD/Mean ratio*
A bar plot showing the SD/Mean ratio of the control and treatment groups in each primary study
```{r}
sd_mean_ratio <- data %>%
  mutate(
    control_sd = as.numeric(control_sd),
    treatment_sd = as.numeric(treatment_sd)
  ) %>%
  group_by(study_id) %>%
  mutate(
    within_study_control_mean = mean(control_mean, na.rm = TRUE),
    within_study_treatment_mean = mean(treatment_mean, na.rm = TRUE),
    within_study_control_sd = mean(control_sd, na.rm = TRUE),
    within_study_treatment_sd = mean(treatment_sd, na.rm = TRUE),
    sd_mean_ratio_control = within_study_control_sd / within_study_control_mean,
    sd_mean_ratio_treatment = within_study_treatment_sd / within_study_treatment_mean
  )

sd_mean_ratio_bar_plot <- sd_mean_ratio %>% 
  ggplot() + 
  geom_histogram(aes(x = sd_mean_ratio_control), fill = "blue", alpha = 0.4) + 
  geom_histogram(aes(x = sd_mean_ratio_treatment), fill = "red", alpha = 0.4) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  guides(size = "none") +
  theme(
    legend.position = "none",
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    plot.caption = element_text(size = 10, color = "gray10", face = "italic")
  ) +
  labs(
    caption = "Red = Control, Blue = Treatment, Purple = Both\nThe value in each bar is the total number of effect sizes",
    x = "SD/Mean Ratio",
    y = "Frequency"
  )

print(sd_mean_ratio_bar_plot)

```

## *Impute missing standard deviations & plot*
We imputed the missing standard deviations using the formula provided in section 13.1 (p. 199) of the Handbook of Meta-analysis in Ecology and Evolution (Koricheva, Gurevitch, and Mengersen, 2013).

To ensure consistency in treatments subjected to repeated stepwise multiple comparisons (i.e., the same data used multiple times to calculate different effect sizes), we maintained the same imputed standard deviations (or standard errors) for the repeated data.

```{r}
# Indicate which individuals are used in more than one control or treatment to calculate sampling variances of non-independent observations differently. 
data_shared_indiv <- group_by(data, exp_id ) %>% 
  summarise(number_treatment= n())
data <- left_join(data, data_shared_indiv, by = "exp_id")


# Calculate the within and between study impacts of pesticides on fish social behaviour
data <- data %>% 
  group_by(study_id) %>% 
  mutate(
    control_sd = as.numeric(control_sd),
    treatment_sd = as.numeric(treatment_sd)) %>%
  group_by(study_id) %>%
  mutate(
    within_study_control_mean = mean(control_mean, na.rm = TRUE),
    within_study_treatment_mean = mean(treatment_mean, na.rm = TRUE),
    within_study_control_sd = mean(control_sd, na.rm = TRUE),
    within_study_treatment_sd = mean(treatment_sd, na.rm = TRUE),
    sd_mean_ratio_control = within_study_control_sd / within_study_control_mean,
    sd_mean_ratio_treatment = within_study_treatment_sd / within_study_treatment_mean) %>% 
  ungroup() %>% 
  mutate(between_study_control_mean=mean(within_study_control_mean, na.rm=T),  
         between_study_treatment_mean=mean(within_study_treatment_mean, na.rm=T),
         between_study_control_sd=mean(within_study_control_sd, na.rm=T), 
         between_study_treatment_sd=mean(within_study_treatment_sd, na.rm=T)) 


# label missing location
data$control_sd_report <- ifelse(is.na(data$control_sd),"Yes","No")
data$treatment_sd_report <- ifelse(is.na(data$treatment_sd),"Yes","No")

data %>% select(control_sd, treatment_sd) %>% impute_missingness() # Missing SD == 3.9%, 36 imputations needed 

data <- as.data.frame(data) # convert into dataframe
data <- impute_SD(data, 
                       columnSDnames = c("control_sd", "treatment_sd"), 
                       columnXnames = c("control_mean", "treatment_mean"), 
                       method = "Bracken1992")


# Convert sd columns to log10 and create a combined dataframe for plotting
data_long <- data %>%
  mutate(log_control_sd = log10(control_sd),
         log_treatment_sd = log10(treatment_sd)) %>%
  pivot_longer(cols = c(log_control_sd, log_treatment_sd), 
               names_to = "type", 
               values_to = "log_sd") %>%
  mutate(reported = ifelse(type == "log_control_sd", control_sd_report, treatment_sd_report))

# Create the plot
imputed_sd_plot <- ggplot(data_long, aes(x = factor(study_id), y = log_sd, color = control_sd_report)) +
  geom_point(size = 2, alpha = 0.5) +
  scale_color_manual(values = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[c(1, 2)]) +
  theme_bw() +
  theme(
    legend.position = "none", 
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5) 
  ) +
  labs(
    caption = "Points with 'red' indicate missing standard deviations that were imputed",
    x = "Study ID",
    y = "Log10(SD Value)"  )

# Print the plot
print(imputed_sd_plot)
```

## *Calculate effect sizes and sampling variances*
```{r}
# Make sure all data is numeric 
data <- data  %>%
  mutate(
    treatment_mean = as.numeric(treatment_mean),
    treatment_sd = as.numeric(treatment_sd),
    treatment_n = as.numeric(treatment_n),
    control_mean = as.numeric(control_mean),
    control_sd = as.numeric(control_sd),
    control_n = as.numeric(control_n)
  )
# Calculate log response ratio (lnRR)
lnRR <- escalc(measure = "ROM", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate log coefficient variation ratio (lnCVR)
lnCVR <- escalc(measure = "CVR", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate the standardised mean difference for sensitivity analysis
SMD <- escalc(measure = "SMD", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate log variation ratio (lnVR)
lnVR <- escalc(measure = "VR", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Summary statistics of effect size estimates
effect_size_summaries <- list(
  lnRR = summary(lnRR$yi),
  lnCVR = summary(lnCVR$yi),
  SMD = summary(SMD$yi),
  VR = summary(lnVR$yi)
)

# Summary statistics of sampling variances
sampling_variance_summaries <- list(
  lnRR = summary(lnRR$vi),
  lnCVR = summary(lnCVR$vi),
  SMD = summary(SMD$vi),
  VR = summary(lnVR$vi)
)

# Calculate precision for each effect size estimate with checks
lnRR$precision <- ifelse(lnRR$vi > 0, 1 / sqrt(lnRR$vi), NA)
lnCVR$precision <- ifelse(lnCVR$vi > 0, 1 / sqrt(lnCVR$vi), NA)
SMD$precision <- ifelse(SMD$vi > 0, 1 / sqrt(SMD$vi), NA)
lnVR$precision <- ifelse(lnVR$vi > 0, 1 / sqrt(lnVR$vi), NA)


# Merge each of the effect size with precision
effect_size_metrics_set <- data.frame(
  lnRR = lnRR$yi, lnRRv = lnRR$vi, lnRR_precision = lnRR$precision,
  lnVR = lnVR$yi, lnVRv = lnVR$vi, lnVR_precision = lnVR$precision,
  lnCVR = lnCVR$yi, lnCVRv = lnCVR$vi, lnCVR_precision = lnCVR$precision,
  SMD = SMD$yi, SMDv = SMD$vi, SMD_precision = SMD$precision,
  control_imputed = data$control_sd_report, treatment_imputed = data$treatment_sd_report)



 # Bind the effect size metrics set to the main data
data <- cbind(data, effect_size_metrics_set)


# Check if `effect_direction` is "change" and not NA, then multiply `lnRR` by -1; otherwise, keep original `lnRR`
data$lnRR <- ifelse(!is.na(data$effect_direction) & data$effect_direction == "change", 
                    -1 * data$lnRR, 
                    data$lnRR)


# Select specific columns including the new precision columns
effect_size_metrics_set_kable <- data[, which(colnames(data) %in% c(
  "study_id", "exp_id", "assay_id", "species_english", "pesticide", "behaviour_assay","effect_direction",
  "lnRR", "lnRRv", "lnRR_precision", 
  "lnCVR", "lnCVRv", "lnCVR_precision", 
  "lnVR", "lnVRv", "lnVR_precision", 
  "SMD", "SMDv", "SMD_precision", 
  "control_imputed", "treatment_imputed"
))] %>% dfround(digits = 3)


# Table of the effect sizes
 kable(effect_size_metrics_set_kable, "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "800px")

# Plot the distribution of effect size estimates (lnRR)
lnRR_dist_plot <- effect_size_metrics_set_kable %>%
  ggplot(aes(lnRR)) +
  geom_histogram(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], col = "black", binwidth = 0.1, alpha = 0.4) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Distribution of Effect Size Estimates (lnRR)",
       x = "lnRR",
       y = "Frequency")

print(lnRR_dist_plot)


 # Plot the distribution of effect size estimates (lnVR)
lnVR_dist_plot <- effect_size_metrics_set_kable %>%
  ggplot(aes(lnCVR)) +
  geom_histogram(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[3], col = "black", binwidth = 0.1, alpha = 0.4) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Distribution of Effect Size Estimates (lnVR)",
       x = "lnVR",
       y = "Frequency")

print(lnVR_dist_plot)
```

## *Dependent effect size estimates*
### *Create phylogentic tree*
We used the *rotl* package (https://peerj.com/preprints/1471/) to retrieve synthetic species tree from Open Tree of Life (https://opentreeoflife.org/). 
 
```{r}
data <- as.data.frame(data)

data$species_latin = as.factor(data$species_latin)

taxa <- tnrs_match_names(names = levels(data$species_latin), context = "Animals")  # Match species names to the Open Tree of Life taxonomy

kable(taxa)  # Display matched species, ensuring each species has a unique match in the Open Tree of Life

taxa$unique_name <- gsub(" ", "_", taxa$unique_name)  # Replace spaces in species names with underscores

phylo_tree <- tol_induced_subtree(ott_ids = taxa$ott_id, label_format = "name")  # Generate a phylogenetic tree based on the Open Tree of Life taxonomy

ott_in_tree <- ott_id(taxa)[is_in_tree(ott_id(taxa))]  # Ensure all identifiers are present in the taxonomy

phylo_tree <- tol_induced_subtree(ott_ids = ott_in_tree)  # Generate a phylogenetic tree including all species present in the taxonomy

is.binary(phylo_tree)  # Check if tree is binary 


# Plot for the phylogenetic tree
plot(phylo_tree,
     cex= 1, #font size
     label.offset =.1,
     no.margin = TRUE)

# Compute branch length
phylo_branched <- compute.brlen(phylo_tree, method = "Grafen", power = 1)  # compute branch lengths using Grafen's method

phylo_branched$tip.label <- strip_ott_ids(phylo_branched$tip.label, remove_underscores = FALSE)  # remove ott ID from species name to match it to the data set

phylo_matrix <- vcv(phylo_branched, cor = T)  # Generate variance covariance matrix to correlate species relatedness 

data <- as.data.frame(data)

# Convert species_latin to lowercase
data <- mutate(data, search_string = tolower(species_latin))

data <- left_join(data, select(taxa, search_string, unique_name, ott_id), by = "search_string")  # Join data sets

data <- data[data$unique_name %in% phylo_branched$tip.label, ]  # Check that species names are well matched with the phylogenetic tree


data$phylogeny <- data$unique_name  # Rename 'unique_name' to 'phylogeny' for the models


```

## *Variance covariance matrices*
To account for the dependency of effect sizes estimates due to being in the same exposure group (cohort) we constructed a series of vcv matrices.
```{r}
#------------------------------lnRR------------------------------#
data<- data[!is.na(data$lnRRv),] 

lnRRVCV <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

lnRRVCV2 <- metafor::vcalc(vi = lnRRv, cluster = exp2_id, obs = assay_id, data = data, rho = 0.5) # Sensitivity analysis with alternative VCV

#------------------------------lnVR------------------------------#
data <- data[!is.na(data$lnVRv),]

lnVRVCV <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

lnVRVCV2 <- metafor::vcalc(vi = lnVRv, cluster = exp2_id, obs = assay2_id, data = data, rho = 0.5) # Sensitivity analysis with alternative VCV

#------------------------------lnCVR------------------------------#
data <- data[!is.na(data$lnCVRv),]

lnCVRVCV <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

#------------------------------SMD------------------------------#
data <- data[!is.na(data$SMDv),]

SMDVCV <- metafor::vcalc(vi = SMDv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)


```

# **Selection of random-effect structure**

Select the "most appropriate" structure for the subsequent statistical modelling.

The potential random effect were:

- 1) Observation (*assay_id*) - A unique id for each pairwise comparison for effect size calculation

- 2) Cohort (*exp_id*) - A unique id for each exposure group in each primary study

- 3) Study (*study_id*) - A unique id for each included primary study

- 4) Pesticide  (*pesticide*) - Each pesticide used in the primary study

- 5) Species (*species*) - Each species used in the primary study

- 6) Phylogeny (*phylogeny*) - The phylogenetic relatedness for each species in the primary studies

We start from fitting a null model without including the above random effects candidates as the default reduced model, and build upon more complex models by adding random-effects a candidate one time. We use the likelihood ratio test to compare the quality of two nested models in terms of information criteria indices (AIC, BIC, AICc). 

## Null model with no random effects (lnRR)
```{r}
# fit a null model as default model
null_mod_lnRR <- rma.mv(yi = lnRR, 
                        V = lnRRVCV, 
                        method = "ML", 
                        test = "t", 
                        data = data, 
                        sparse = TRUE ) # Use ML to compare information criteria

summary(null_mod_lnRR)

```

## Add *assay_id* as a random effect and compare with the null model (lnRR)
```{r}
mod_lnRR.assay_id <- rma.mv(yi = lnRR, 
                            V = lnRRVCV,
                            random =  ~1 | assay_id,
                            method = "ML", 
                            test = "t", 
                            data = data, 
                            sparse = T)

summary(mod_lnRR.assay_id)

anova(null_mod_lnRR,mod_lnRR.assay_id)
```

## Add *study_id* as a random effect to the above better model (that used *obs_ID* a random effect) (lnRR)
```{r}
mod_lnRR.assay_id.study_id <- rma.mv(yi = lnRR,
                                     V = lnRRVCV,
                                     random = list(~1 | study_id, 
                                                   ~1 | assay_id),
                                     method = "ML",
                                     test = "t", 
                                     data = data, 
                                     sparse = T)

summary(mod_lnRR.assay_id.study_id)

anova(mod_lnRR.assay_id,mod_lnRR.assay_id.study_id)

```

## Add *exp_id* as a random effect to the above model (that used *assay_id* and *study_id* as random effets) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.exp_id <- rma.mv(yi = lnRR,
                                            V = lnRRVCV,
                                            random = list(~1 | study_id,
                                                          ~1 | exp_id,
                                                          ~1 | assay_id),
                                            method = "ML",
                                            test = "t", 
                                            data = data,
                                            sparse = T)

summary(mod_lnRR.assay_id.study_id.exp_id)

anova(mod_lnRR.assay_id.study_id,mod_lnRR.assay_id.study_id.exp_id)

```

## Add *species* as a random effect to the better model (that used *assay_id* and *study_id* as random effets) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species <- rma.mv(yi = lnRR,
                                             V = lnRRVCV,
                                             random = list(~1 | study_id, 
                                                           ~1 | assay_id,
                                                           ~1 | species_latin),
                                             method = "ML",
                                             test = "t", 
                                             data = data,
                                             sparse = T)

summary(mod_lnRR.assay_id.study_id.species)

anova(mod_lnRR.assay_id.study_id,mod_lnRR.assay_id.study_id.species)

i2_ml(mod_lnRR.assay_id.study_id.species)
```

## Add *phylogeny* as a random effect to the better model (that used *assay_id* , *study_id* and *species* as random effects) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species.phylogeny <- rma.mv(yi = lnRR,
                                                       V = lnRRVCV,
                                                       random = list(~1 | study_id,
                                                                     ~1 | assay_id,
                                                                     ~1 | species_latin,
                                                                     ~1 | phylogeny),
                                                       method = "ML",
                                                       test = "t", 
                                                       data = data, 
                                                       sparse = T,
                                                       R = list(phylogeny = phylo_matrix))

summary(mod_lnRR.assay_id.study_id.species.phylogeny)

fitstats(mod_lnRR.assay_id.study_id.species, mod_lnRR.assay_id.study_id.species.phylogeny)

i2_ml(mod_lnRR.assay_id.study_id.species.phylogeny)
```

## Add *pesticide* as a random effect to the above model (that used *assay_id* , *study_id*, *species* and *phylogeny* as random effects) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species.pesticide <- rma.mv(yi = lnRR,
                                                       V = lnRRVCV,
                                                       random = list(~1 | study_id,
                                                                     ~1 | assay_id,
                                                                     ~1 | species_latin,
                                                                     ~1 | pesticide),
                                                       method = "ML",
                                                       test = "t", 
                                                       data = data, 
                                                       sparse = T)

summary(mod_lnRR.assay_id.study_id.species.pesticide)

anova(mod_lnRR.assay_id.study_id.species, mod_lnRR.assay_id.study_id.species.pesticide)

i2_ml(mod_lnRR.assay_id.study_id.species.pesticide)
```

## Null model with no random effects (lnVR)
```{r}
# fit a null model as default model
null_mod_lnVR <- rma.mv(yi = lnVR, 
                         V = lnVRVCV, 
                         method = "ML", 
                         test = "t", 
                         data = data, 
                         sparse = TRUE ) # Use ML to compare information criteria

summary(null_mod_lnVR)

```

## Add *assay_id* as a random effect and compare with the null model (lnVR)
```{r}
mod_lnVR.assay_id <- rma.mv(yi = lnVR, 
                             V = lnVRVCV,
                             random =  ~1 | assay_id,
                             method = "ML", 
                             test = "t", 
                             data = data, 
                             sparse = T)

summary(mod_lnVR.assay_id)

anova(null_mod_lnVR, mod_lnVR.assay_id)

```

## Add *study_id* as a random effect to the above better model (that used *assay_id* a random effect) (lnVR)
```{r}
mod_lnVR.assay_id.study_id <- rma.mv(yi = lnVR,
                                      V = lnVRVCV,
                                      random = list(~1 | study_id, 
                                                    ~1 | assay_id),
                                      method = "ML",
                                      test = "t", 
                                      data = data, 
                                      sparse = T)

summary(mod_lnVR.assay_id.study_id)

anova(mod_lnVR.assay_id, mod_lnVR.assay_id.study_id)

```

## Add *exp_id* as a random effect to the above better model (that used *assay_id* and *study_id* as random effets) (lnVR)
```{r}
mod_lnVR.assay_id.study_id.exp_id <- rma.mv(yi = lnVR,
                                             V = lnVRVCV,
                                             random = list(~1 | study_id,
                                                           ~1 | exp_id,
                                                           ~1 | assay_id),
                                             method = "ML",
                                             test = "t", 
                                             data = data,
                                             sparse = T)

summary(mod_lnVR.assay_id.study_id.exp_id)

anova(mod_lnVR.assay_id.study_id, mod_lnVR.assay_id.study_id.exp_id)

```

## Add *species* as a random effect to the above better model (that used *assay_id* and *study_id* as random effets) (lnVR)
```{r}
mod_lnVR.assay_id.study_id.species <- rma.mv(yi = lnVR,
                                              V = lnVRVCV,
                                              random = list(~1 | study_id, 
                                                            ~1 | assay_id,
                                                            ~1 | species_latin),
                                              method = "ML",
                                              test = "t", 
                                              data = data,
                                              sparse = T)

summary(mod_lnVR.assay_id.study_id.species)

anova(mod_lnVR.assay_id.study_id, mod_lnVR.assay_id.study_id.species)

```

## Add *phylogeny* as a random effect to the above better model (that used *assay_id* , *study_id* and *species* as random effects) (lnVR)
```{r}
mod_lnVR.assay_id.study_id.species.phylogeny <- rma.mv(yi = lnVR,
                                                        V = lnVRVCV,
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | phylogeny),
                                                        method = "ML",
                                                        test = "t", 
                                                        data = data, 
                                                        sparse = T,
                                                        R = list(phylogeny = phylo_matrix))

summary(mod_lnVR.assay_id.study_id.species.phylogeny)

anova(mod_lnVR.assay_id.study_id.species, mod_lnVR.assay_id.study_id.species.phylogeny)

```

## Add *pesticide* as a random effect to the above better model (that used *assay_id* , *study_id*, *species* and *phylogeny* as random effects) (lnVR)
```{r}
mod_lnVR.assay_id.study_id.species.phylogeny.pesticide <- rma.mv(yi = lnCVR,
                                                                  V = lnCVRVCV,
                                                                  random = list(~1 | study_id,
                                                                                ~1 | assay_id,
                                                                                ~1 | species_latin,
                                                                                ~1 | phylogeny,
                                                                                ~1 | pesticide),
                                                                  method = "ML",
                                                                  test = "t", 
                                                                  data = data, 
                                                                  sparse = T,
                                                                  R = list(phylogeny = phylo_matrix))

summary(mod_lnVR.assay_id.study_id.species.phylogeny.pesticide)

```

# **Intercept only meta-analysis models**

## Intercept only model (lnRR)
```{r}
# Model
lnRR_intercept_only <- rma.mv(yi = lnRR,
                              V = lnRRVCV,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide,
                                            ~1 | phylogeny),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T,
                              R = list(phylogeny = phylo_matrix))

# Summary statistics 
summary(lnRR_intercept_only)

mod_results(lnRR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only)

# Given point estimate of lnRR
lnRR_point <- -0.2669

# Calculate the percentage change
lnRR_percentage_change <- (1 - exp(lnRR_point)) * 100
lnRR_percentage_change

```

## Intercept only model (lnVR)
```{r}
# Model
lnVR_intercept_only <- rma.mv(yi = lnVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide,
                                            ~1 | phylogeny),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T,
                              R = list(phylogeny = phylo_matrix))
                              
  


# Summary statistics 
summary(lnVR_intercept_only)

mod_results(lnVR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnVR_intercept_only)

# Given point estimate of lnRR
lnVR_point <- -0.0728

# Calculate the percentage change
lnVR_percentage_change <- (1 - exp(lnVR_point)) * 100
lnVR_percentage_change

```

## Figure 2
```{r}
# orchard plot
intercept_only.lnRR_orchard <- orchaRd::orchard_plot(lnRR_intercept_only,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             g = TRUE,
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 3., 
             branch.size = 1.5,
             twig.size = 1) +
    scale_fill_manual(values = RColorBrewer::brewer.pal(8, "Dark2")[1]) +
  scale_x_discrete(labels = c("Model estimates")) 


# orchaRd plot
intercept_only.lnVR__orchard <- orchaRd::orchard_plot(lnVR_intercept_only,
             group = "study_id",
             xlab = "lnVR",
             data = data,
            g = TRUE,
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 3., 
             branch.size = 1.5,
             twig.size = 1) +
    scale_fill_manual(values = RColorBrewer::brewer.pal(8, "Dark2")[2]) +
  scale_x_discrete(labels = c("Model estimates")) +
plot_annotation(tag_levels = "b)")




# Combine the two plots vertically
main_text_figure_2 <- intercept_only.lnRR_orchard + intercept_only.lnVR__orchard 

# ggsave(here("figures", "main_text_figure_2.jpg"),width = 20, height = 10, units = "cm", dpi = 800)
# ggsave(here("figures", "main_text_figure_2.pdf"),width = 20, height = 10, units = "cm", dpi = 800)

```


# **Single moderator meta-regression**

## **Behaviour characteristics**

###  *Moderating effects of behaviour type (lnRR)*
```{r}
# Model
lnRR_mod_behaviour_class <- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)


# Summary results
summary(lnRR_mod_behaviour_class)

mod_results(lnRR_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class)

# Given point estimate of lnRR
courtship_lnRR_point <- -0.4280

# Calculate the percentage change
courtship_lnRR_percentage_change <- (1 - exp(courtship_lnRR_point)) * 100
courtship_lnRR_percentage_change


```

###  *Moderating effects of behaviour type (lnVR)*
```{r}
# Model
lnVR_mod_behaviour_class <- rma.mv(yi = lnVR,
                               V = lnVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary statistics
summary(lnVR_mod_behaviour_class)

mod_results(lnVR_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_behaviour_class)

```

### *orchaRd plots for the moderating effects of behaviour type*
```{r}
# orchaRd plot
behav_mod.lnRR <- orchaRd::orchard_plot(lnRR_mod_behaviour_class,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "behaviour_measured_standardised",
            g = TRUE,
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 3., 
             branch.size = 1.5,
             twig.size = 1,
            angle = 45) +
      scale_fill_manual(values = RColorBrewer::brewer.pal(8, "Dark2")) 

# orchaRd plot
behav_mod.lnVR <- orchaRd::orchard_plot(lnVR_mod_behaviour_class,
             group = "study_id", 
             xlab = "lnVR",
            mod = "behaviour_measured_standardised",
             data = data,
            g = TRUE,
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 3., 
             branch.size = 1.5,
             twig.size = 1,
             angle = 45) +
    scale_fill_manual(values = RColorBrewer::brewer.pal(8, "Dark2"))


main_text_figure_3 <- behav_mod.lnRR + behav_mod.lnVR 

# ggsave(here("figures", "main_text_figure_3.jpg"),width = 24, height = 14, units = "cm", dpi = 800)
# ggsave(here("figures", "main_text_figure_3.pdf"),width = 24, height = 14, units = "cm", dpi = 800)
```

### *Moderate by assay (lnRR)*
```{r}
lnRR_mod_assay <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)



summary(lnRR_mod_assay)

r2_ml(lnRR_mod_assay)

# contrast 
lnRR_mod_assay_contrast <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                        ~1 | assay_id,
                                        ~1 | species_latin,
                                        ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 ,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(lnRR_mod_assay_contrast)


# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_assay_contrast,
                      group = "study_id", 
                      xlab = "lnVR",
                      data = data,
                      mod = "behavioural_assay_standardised2",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_assay,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "behavioural_assay_standardised2",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

### *Moderate by assay (lnVR)*
```{r}
lnVR_mod_assay <- rma.mv(yi = lnVR,
                          V = lnVRVCV,
                          random = list(~1 | study_id,
                                        ~1 | assay_id,
                                        ~1 | species_latin,
                                        ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(lnVR_mod_assay)

# contrast 
lnVR_mod_assay_contrast <- rma.mv(yi = lnVR,
                          V = lnVRVCV,
                          random = list(~1 | study_id,
                                        ~1 | assay_id,
                                        ~1 | species_latin,
                                        ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 ,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(lnVR_mod_assay_contrast)


# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_assay_contrast,
                      group = "study_id", 
                      xlab = "lnVR",
                      data = data,
                      mod = "behavioural_assay_standardised2",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)
```

## **Pesticide characteristics**
## *Moderate by pesticide chemical class (lnRR)*
```{r}
# Model
lnRR_mod_pesticide <- rma.mv(yi = lnRR,
                              V = lnRRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnRR_mod_pesticide)

mod_results(lnRR_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_pesticide)

```

## *Moderate by pesticide chemical class (lnVR)*
```{r}
# Model
lnVR_mod_pesticide <- rma.mv(yi = lnVR,
                              V = lnVRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnVR_mod_pesticide)

mod_results(lnVR_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_pesticide)

```


```{r}

pesticide.mod.lnRR <- orchaRd::orchard_plot(lnRR_mod_pesticide,
                      group = "study_id", 
                      xlab = "lnRR",
                      data = data,
                      mod = "pesticide_chemical_class",
                      k.pos = "right",
                      colour = FALSE,
                      fill = TRUE,  
                      trunk.size = 3, 
                      branch.size = 1.5,
                      twig.size = 1,
                      angle = 45) +
  scale_fill_manual(values = c(RColorBrewer::brewer.pal(8, "Dark2"), 
                               "#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854"))

pesticide.mod.lnVR <- orchaRd::orchard_plot(lnVR_mod_pesticide,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 3, 
             branch.size = 1.5,
             twig.size = 1,
             angle = 45) +
  scale_fill_manual(values = c(RColorBrewer::brewer.pal(8, "Dark2"), 
                               "#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854")) +
  theme(axis.text.y = element_blank())

pesticide.mod.lnVR <- pesticide.mod.lnRR + pesticide.mod.lnVR 


 ggsave(here("figures", "main_text_figure_4.jpg"),width = 24, height = 28, units = "cm", dpi = 800)
 ggsave(here("figures", "main_text_figure_4.pdf"),width = 24, height = 28, units = "cm", dpi = 800)


```



## *Moderate by concentration of pesticide (lnRR)*
```{r}
# Create dataframe for model with consistent dosage units
data_dosage_model <- data %>% 
  filter(dosage != "not reported") %>% 
filter(dosage_unit != "not reported") %>% 
filter(!dosage_unit %in% c("nm", "um", "nM")) %>%
  mutate(dosage = as.numeric(dosage),
         dosage_unit = as.character(dosage_unit),
         dosage_unit_consistent = case_when(
           dosage_unit == "mg/L" ~ "ug/L", 
           dosage_unit == "ng/L" ~ "ug/L",
           dosage_unit == "g/L" ~ "ug/L",
           dosage_unit == "ppb" ~ "ug/L", 
           dosage_unit == "ppm" ~ "ug/L", 
           TRUE ~ dosage_unit),
         dosage_convert_ugL = case_when(
           dosage_unit == "mg/L" ~ dosage * 1000,
           dosage_unit == "ng/L" ~ dosage / 1000,
           dosage_unit == "g/L" ~ dosage/1000000,
           dosage_unit == "ppm" ~ dosage*1000, 
           TRUE ~ dosage)) %>% 
   filter(!is.na(dosage_convert_ugL)) %>% 
    mutate(log_dosage_convert_ugL = log(dosage_convert_ugL)) 

# Recalculate the VCV matrix based on the new data frame 
lnRRVCV_dosage <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_dosage_model, rho = 0.5)

# Model
lnRR_mod_dosage <- rma.mv(yi = lnRR,
                               V = lnRRVCV_dosage,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~log_dosage_convert_ugL -1,
                               method = "REML",
                               test = "t", 
                               data = data_dosage_model,
                               sparse = T)

# Summary results 
summary(lnRR_mod_dosage)

dosage_mod_lnRR_results <- mod_results(lnRR_mod_dosage, mod = "log_dosage_convert_ugL", data = data_dosage_model, group = "study_id")  # For prediction intervals

r2_lnRR_dosage <- r2_ml(lnRR_mod_dosage, data_dosage_model)

# Bubble plot
bubble_plot(dosage_mod_lnRR_results, mod = "log_dosage_convert_ugL", group = "study_id", data = data_dosage_model, x = "dosage_convert_ugL",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnRR_dosage[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Dosage")

```

## *Moderate by concentration of pesticide (lnVR)*
```{r}
# Recalculate the VCV matrix based on the new data frame 
lnVRVCV_dosage <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data_dosage_model, rho = 0.5)

## Model
lnVR_mod_dosage <- rma.mv(yi = lnVR,
                               V = lnVRVCV_dosage,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~log_dosage_convert_ugL -1,
                               method = "REML",
                               test = "t", 
                               data = data_dosage_model,
                               sparse = T)

# Summary results
summary(lnVR_mod_dosage)

dosage_mod_lnVR_results <- mod_results(lnVR_mod_dosage, mod = "log_dosage_convert_ugL", data = data_dosage_model, group = "study_id")  # For prediction intervals

r2_lnVR_dosage <- r2_ml(lnVR_mod_dosage, data_dosage_model)

# Bubble plot
bubble_plot(dosage_mod_lnVR_results, mod = "log_dosage_convert_ugL", group = "study_id", data = data_dosage_model, x = "dosage_convert_ugL",
    y = "lnVR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnVR_dosage[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Dosage")

```

## *Moderate by duration of pesticide (lnRR)*
```{r}
# Create dataframe for model with consistent duration units
data_duration_model <- data %>% 
  filter(!is.na(duration), duration != "not reported") %>%
  mutate(duration = as.numeric(duration),
         duration_unit = as.character(duration_unit),
           duration_unit_consistent = case_when(
          duration_unit == "minutes" ~ "hours",
          duration_unit == "days" ~ "hours",
          duration_unit == "weeks" ~ "hours",
           TRUE ~ duration_unit),
 duration_convert = case_when(
    duration_unit == "minutes" ~ duration/ 60, 
    duration_unit == "days" ~ duration*24, 
    duration_unit == "weeks" ~ duration*168,
    TRUE ~ duration))


# Recalculate the VCV matrix based on the new data frame 
lnRRVCV_duration <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_duration_model, rho = 0.5)

# Model
lnRR_mod_duration <- rma.mv(yi = lnRR,
                               V = lnRRVCV_duration,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~duration_convert -1,
                               method = "REML",
                               test = "t", 
                               data = data_duration_model,
                               sparse = T)


# Summary results
summary(lnRR_mod_duration)

duration_mod_lnRR_results <- mod_results(lnRR_mod_duration, mod = "duration_convert", data = data_duration_model, group = "study_id")  # For prediction intervals

r2_lnRR_duration <- r2_ml(lnRR_mod_duration, data_duration_model)

# Bubble plot
bubble_plot(duration_mod_lnRR_results, mod = "duration_convert", group = "study_id", data = data_duration_model, x = "duration_convert",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnRR_duration[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Duration")

```

## *Moderate by duration of pesticide (lnVR)* 
```{r}
# Recalculate the VCV matrix based on the new data frame 
lnVRVCV_duration <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data_duration_model, rho = 0.5)

## Model
lnVR_mod_duration <- rma.mv(yi = lnVR,
                               V = lnVRVCV_duration,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~log(duration_convert) -1,
                               method = "REML",
                               test = "t", 
                               data =data_duration_model ,
                               sparse = T)

# Summary results
summary(lnVR_mod_duration)

lnVR_mod_duration_results <- mod_results(lnVR_mod_duration, mod = "duration_convert", data = data_duration_model, group = "study_id")  # For prediction intervals

r2_lnVR_duration <- r2_ml(lnVR_mod_duration, data_duration_model)

# Bubble plot
bubble_plot(lnVR_mod_duration_results, mod = "duration_convert", group = "study_id", data = data_duration_model, x = "duration_convert",
    y = "lnVR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnVR_duration[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Duration")

```

## *Moderate by control solvent used (lnRR)*
```{r}
# Model
lnRR_mod_solvent <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~control_solvent -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)
# Summary results
summary(lnRR_mod_solvent)

mod_results(lnRR_mod_solvent, mod = "control_solvent", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_solvent)


# Model
lnRR_mod_solvent2 <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~solvent2 -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)
# Summary results
summary(lnRR_mod_solvent2)

mod_results(lnRR_mod_solvent2, mod = "solvent2", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_solvent2)


# Contrast Model
lnRR_mod_solvent2_contrast <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~solvent2 ,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)
# Summary results
summary(lnRR_mod_solvent2_contrast)

mod_results(lnRR_mod_solvent2_contrast, mod = "solvent2", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_solvent2_contrast)


# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_solvent,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "control_solvent",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)


# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_solvent2,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "solvent2",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## *Moderate by control solvent used (lnVR)*
```{r}
# Model
lnVR_mod_solvent <- rma.mv(yi = lnVR,
                              V = lnVRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~control_solvent -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnVR_mod_solvent)

mod_results(lnVR_mod_solvent, mod = "control_solvent", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_solvent)

# Model
lnVR_mod_solvent2 <- rma.mv(yi = lnVR,
                        V = lnVRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~solvent2 -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)
# Summary results
summary(lnVR_mod_solvent2)

mod_results(lnVR_mod_solvent2, mod = "solvent2", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_solvent2)


# Model
lnVR_mod_solvent2_contrast <- rma.mv(yi = lnVR,
                        V = lnVRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~solvent2 ,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)
# Summary results
summary(lnVR_mod_solvent2_contrast)

mod_results(lnVR_mod_solvent2_contrast, mod = "solvent2", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_solvent2_contrast)

# orchaRd plot 
orchaRd::orchard_plot(lnVR_mod_solvent,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "control_solvent",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

# orchaRd plot 
orchaRd::orchard_plot(lnVR_mod_solvent2,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "solvent2",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## **Species characteristics**

## *Moderate by species (lnRR)*
```{r}
# Model
lnRR_mod_species <- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_english -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnRR_mod_species)

r2_ml(lnRR_mod_species)


mod_results(lnRR_mod_species, mod = "species_english", data = data, group = "study_id")  # For prediction intervals


```

## *Moderate by species (lnVR)*
```{r}
## ModeL
lnVR_mod_species <- rma.mv(yi = lnVR,
                               V = lnVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_english -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)



# Summary results
summary(lnVR_mod_species)

mod_results(lnVR_mod_species, mod = "species_english", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_species)



```


```{r}
# First plot (lnRR_mod_species)
species.mod.lnRR <- orchaRd::orchard_plot(lnRR_mod_species,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "species_english",
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  # Set fill to TRUE to match the style
             trunk.size = 3, 
             branch.size = 1.5,
             twig.size = 1,
             angle = 45) +
  scale_fill_manual(values = c(RColorBrewer::brewer.pal(8, "Dark2"), 
                               "#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854"))

# Second plot (lnVR_mod_species)
species.mod.lnVR <- orchaRd::orchard_plot(lnVR_mod_species,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "species_english",
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  # Set fill to TRUE to match the style
             trunk.size = 3, 
             branch.size = 1.5,
             twig.size = 1,
             angle = 45) +
  scale_fill_manual(values = c(RColorBrewer::brewer.pal(8, "Dark2"), 
                               "#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854")) +
  theme(axis.text.y = element_blank())

# Combine the plots (if needed)
main_text_figure_4 <- species.mod.lnRR + species.mod.lnVR

# Save the plots
ggsave(here("figures", "species_plot_figure.jpg"), plot = main_text_figure_4, width = 24, height = 28, units = "cm", dpi = 800)
ggsave(here("figures", "species_plot_figure.pdf"), plot = main_text_figure_4, width = 24, height = 28, units = "cm", dpi = 800)

```

## *Moderate by sex (lnRR)*
```{r}
# Model
lnRR_mod_sex <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex - 1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)

# Summary results 
summary(lnRR_mod_sex)

mod_results(lnRR_mod_sex, mod = "sex", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_sex)

data_sex <- data %>% filter(sex == c("male", "female"))

lnRRVCV_sex <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_sex, rho = 0.5)

lnRR_mod_sex_contrast <- rma.mv(yi = lnRR,
                        V = lnRRVCV_sex,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex ,
                        method = "REML",
                        test = "t", 
                        data = data_sex,
                        sparse = T)


summary(lnRR_mod_sex_contrast)



# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_sex,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "sex",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## *Moderate by sex (lnVR)*
```{r}
# Model
lnVR_mod_sex <- rma.mv(yi = lnVR,
                        V = lnVRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)




# Summary results
summary(lnVR_mod_sex)

mod_results(lnVR_mod_sex, mod = "sex", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_sex)

lnVRVCV_sex <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data_sex, rho = 0.5)


# Model
lnVR_mod_sex_contrast <- rma.mv(yi = lnVR,
                        V = lnVRVCV_sex,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex ,
                        method = "REML",
                        test = "t", 
                        data = data_sex,
                        sparse = T)

summary(lnVR_mod_sex_contrast)


# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_sex,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "sex",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## *Moderate by source of fish (lnRR)*
```{r}
## ModeL
lnRR_mod_source <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~source -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

# Summary results
summary(lnRR_mod_source)

mod_results(lnRR_mod_source, mod = "source", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_source)


## ModeL
lnRR_mod_source_contrast <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~source2 ,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(lnRR_mod_source_contrast)


# orchaRd plot 
orchaRd::orchard_plot(lnRR_mod_source,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "source",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

## *Moderate by source of fish (lnVR)*
```{r}
## Model
lnVR_mod_source <- rma.mv(yi = lnVR,
                           V = lnVRVCV,
                           random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                           mods = ~source -1,
                           method = "REML",
                           test = "t", 
                           data = data,
                           sparse = T)

# Summary results
summary(lnVR_mod_source)

mod_results(lnVR_mod_source, mod = "source", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_source)


# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_source,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "source",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

# **Model selection and multi-model inference **

## *lnRR model selection and multi-model inference*
```{r}
mlmr.full.lnRR <- rma.mv(yi = lnRR, 
                    V = lnRRVCV, 
                    random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                     mods = ~ behaviour_measured_standardised + behavioural_assay_standardised2 + pesticide_chemical_class + control_solvent +
                      species_latin + sex +  source, 
                     method = "ML", 
                    test = "t", 
                    data = data, 
                    sparse = T)


r2_ml(mlmr.full.lnRR, data = data)

eval(metafor:::.MuMIn)  # use eval() function to extract helper functions from MuMIn and make them usable in metafor.

mlmr.dredge.lnRR <- dredge(mlmr.full.lnRR, beta = "none", evaluate = TRUE, rank = "AICc", trace=2)


# save to save time - running this model is time-consuming

saveRDS(mlmr.dredge.lnRR, file = "mlmr.dredge.lnRR.Rds")
mlmr.dredge.lnRR <- readRDS(file = "mlmr.dredge.lnRR.Rds")

save(mlmr.dredge.lnRR, file = "mlmr.dredge.lnRR.Rdata") 
load(here("R.data", "mlmr.dredge.lnRR.Rdata"))


# multimodel inference
summary(mlmr.full.lnRR)



# Select "best" models based on delta <= 2
best_model <- subset(mlmr.dredge.lnRR, delta <= 2, recalc.weights = FALSE)

# Display the results in a scrollable kable table
best_model %>%
  kable("html") %>%
  kable_styling("bordered", position = "left") %>%
  scroll_box(width = "100%", height = "800px")


# the relative importance values for the predictors

weights_lnRR <- sw(mlmr.dredge.lnRR) 


# Convert the named vector into a data frame
weights_lnRR_df <- data.frame(
  predictor = names(weights_lnRR),  # First column: the names of the vector
  weight = as.numeric(weights_lnRR) # Second column: the values of the vector
)


weights_lnRR_df %>% ggplot(aes(x = reorder(predictor, weight), y = weight), fill = "lightgrey") +
  geom_col(aes(), width = 0.7) +
  #scale_fill_manual(values = cols) +
  coord_flip() + 
  labs(y = "Akaike weights", x = "Moderator variables", title = "") +
  #ylim(0,1)+
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
  #coord_cartesian(ylim = c(0,1)) + 
  geom_text(aes(label=scales::percent(weight, accuracy = 1)), size = 3, position = position_stack(vjust = 0.5), color = "white", fontface = "bold") +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.text.y = element_text(size = 12, color = "black"),
        axis.title.y = element_text(size = 12, color = "black"),
        axis.ticks.y = element_blank(),
        axis.line.x = element_line(colour = "black")) +
  scale_x_discrete(labels = c("Source of fish", "Behaviour measured","Control Solvent","Species","Sex of fish","Pesticide chemical class","Behavioural assay"))
dev.off()

```


```{r}
mlmr.full.lnVR <- rma.mv(yi = lnVR, 
                    V = lnVRVCV, 
                    random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
 mods = ~ behaviour_measured_standardised + behavioural_assay_standardised2 + pesticide_chemical_class + control_solvent +
                      species_latin + sex +  source, 
                     method = "ML", 
                    test = "t", 
                    data = data, 
                    sparse = TRUE)

r2_ml(mlmr.full.lnVR, data = data)

eval(metafor:::.MuMIn)  # use eval() to extract helper functions from MuMIn and make them usable in metafor.

mlmr.dredge.lnVR <- dredge(mlmr.full.lnVR, beta = "none", evaluate = TRUE, rank = "AICc", trace = 2)

# Save to save time - running this model is time-consuming
saveRDS(mlmr.dredge.lnVR, file = "mlmr.dredge.lnVR.Rds")
mlmr.dredge.lnVR <- readRDS(file = "mlmr.dredge.lnVR.Rds")

save(mlmr.dredge.lnVR, file = "mlmr.dredge.lnVR.Rdata") 
load(here("R.data", "mlmr.dredge.lnVR.Rdata"))

# Multimodel inference
summary(mlmr.full.lnVR)

# Select "best" models based on delta <= 2
best_model_vr <- subset(mlmr.dredge.lnVR, delta <= 2, recalc.weights = FALSE)

# Display the results in a scrollable kable table
best_model_vr %>%
  kable("html") %>%
  kable_styling("bordered", position = "left") %>%
  scroll_box(width = "100%", height = "800px")

# Relative importance values for the predictors
weights_lnVR <- sw(mlmr.dredge.lnVR)

# Convert the named vector into a data frame
weights_lnVR_df <- data.frame(
  predictor = names(weights_lnVR),  # First column: the names of the vector
  weight = as.numeric(weights_lnVR) # Second column: the values of the vector
)

weights_lnVR_df %>% ggplot(aes(x = reorder(predictor, weight), y = weight), fill = "lightgrey") +
  geom_col(aes(), width = 0.7) +
  coord_flip() + 
  labs(y = "Akaike weights", x = "Moderator variables", title = "") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
  geom_text(aes(label = scales::percent(weight, accuracy = 1)), size = 3, position = position_stack(vjust = 0.5), color = "white", fontface = "bold") +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.text.y = element_text(size = 12, color = "black"),
        axis.title.y = element_text(size = 12, color = "black"),
        axis.ticks.y = element_blank(),
        axis.line.x = element_line(colour = "black")) +
  scale_x_discrete(labels = c("Source of fish", "Behaviour measured","Control Solvent","Species","Sex of fish","Pesticide chemical class","Behavioural assay"))
dev.off()

```

# Publication bias

## Funnel plot
```{r}
# Create the funnel plot with adjustments
funnel.1 <- funnel(lnRR_intercept_only,
       yaxis = "seinv",  # Inverse of standard error (precision) as the y axis
       level = c(95),  # levels of statistical significance highlighted
       shade = c("white"),  # shades for different levels of statistical significance
       legend = FALSE,  # display legend
       pch = 21,
       refline = 0,
       ylab = "Precision (1/SE)") 


```

## Time lag bias
```{r}
data$pub_year <- str_extract(data$study_id, "\\d{4}")


data$pub_year <- as.numeric(data$pub_year)


time_lag_bias_model <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~pub_year -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(time_lag_bias_model)


lnRR_mod_time_lag_results <- mod_results(time_lag_bias_model, mod = "pub_year", data = data, group = "study_id")  # For prediction intervals



r2_lnRR_time_lag <- r2_ml(time_lag_bias_model, data)


# Calculate R^2 value
r2_lnRR_time_lag <- r2_ml(time_lag_bias_model, data)

# Get the minimum year for x-axis limit
min_year <- min(data$pub_year, na.rm = TRUE)

# Create the bubble plot
bubble_plot(lnRR_mod_time_lag_results, mod = "pub_year", group = "study_id", data = data, x = "pub_year",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) +
  annotate(geom = "text",
    x = min_year + 2, y = max(data$lnRR, na.rm = TRUE) + 0.2, label = paste0("italic(R)^{2} ==", round(r2_lnRR_time_lag[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
  xlab("Publication Year") +
  scale_x_continuous(limits = c(min_year, max(data$pub_year, na.rm = TRUE)))



```

## Heteroscadacity check
```{r}
qplot(y = sqrt(residuals(time_lag_bias_model)^2), x = fitted(time_lag_bias_model)) + # plot sqrt(residuals^2) against fitted values
      geom_point() +
      geom_smooth(method = "lm") + # method ="lm" to generate a straight line 
      geom_hline(yintercept = 0, colour="red") 
```

## Egger's regression
```{r}
eggers_regression <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~sqrt(lnRRv) ,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)


summary(eggers_regression)

egger_pred <- predict.rma(eggers_regression)


data %>% mutate(fit=egger_pred$pred, 
               ci.lb=egger_pred$ci.lb,
               ci.ub=egger_pred$ci.ub,
               pr.lb=egger_pred$cr.lb,
               pr.ub=egger_pred$cr.ub) %>% 
ggplot(aes(x = sqrt(lnRRv), y = lnRR)) +
     geom_ribbon(aes(ymin = pr.lb, ymax = pr.ub, color = NULL), alpha = .1) +
     geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = .3) +
     geom_point(size=2,shape=21, alpha=0.7, fill=RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1], col="gray25",stroke=1) +
     geom_line(aes(y = fit), size = 1.2)+  
  labs(x = "Standard error", y = "lnRR") +
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```

# **Sensitivity Analysis** 

## *Leave-one-out analysis*

### *Leave one study out*

#### Intercept only model (lnRR)
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_lnRR <- list()
VCV_leave_study_out_lnRR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnRRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_lnRR[[i]] <- rma.mv(yi = lnRR, V = VCV_leave_study_out_lnRR[[i]], 
                                            random = list(~1 | study_id,
                                                          ~1 | assay_id,
                                                          ~1 | species_latin,
                                                          ~1 | pesticide),
                                            method = "REML", 
                                            test = "t",
                                            data = data_study_leave,
                                            sparse = TRUE)
}

results.leave_study_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_lnRR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_study_out_lnRR_forest_plot <- ggplot(results.leave_study_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_one_study_out_lnRR_forest_plot)

results.leave_study_out_model_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Intercept only model (lnVR)
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_lnVR <- list()
VCV_leave_study_out_lnVR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_lnVR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnVRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_lnVR[[i]] <- rma.mv(yi = lnVR, V = VCV_leave_study_out_lnVR[[i]], 
                                            random = list(~1 | study_id,
                                                          ~1 | assay_id,
                                                          ~1 | species_latin,
                                                          ~1 | pesticide),
                                            method = "REML", 
                                            test = "t",
                                            data = data_study_leave,
                                            sparse = TRUE)
}

results.leave_study_out_model_lnVR <- as.data.frame(cbind(
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_lnVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_lnVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_lnVR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_lnVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_study_out_lnVR_forest_plot <- ggplot(results.leave_study_out_model_lnVR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_one_study_out_lnVR_forest_plot)

results.leave_study_out_model_lnVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")


```

### *Leave one species out*

#### Intercept only model (lnRR)
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_lnRR <- list()
VCV_leave_species_out_lnRR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnRRv, cluster = data_species_leave$study_id, r = 0.5)
  
    # Model fitting
    leave_species_out_model_lnRR[[i]] <- rma.mv(yi = data_species_leave$lnRR,
                                         V = VCV_leave_species_out_lnRR[[i]],
                                         random = list(~1 | study_id,
                                                       ~1 | assay_id,
                                                       ~1 | species_latin,
                                                       ~1 | pesticide),
                                         method = "REML", 
                                         test = "t",
                                         data = data_species_leave,
                                         sparse = TRUE)
} 


results.leave_species_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_species_out_model_lnRR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_species_out_lnRR_forest_plot <- ggplot(results.leave_species_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_one_species_out_lnRR_forest_plot)
```

#### Intercept only model (lnVR) 
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_lnVR <- list()
VCV_leave_species_out_lnVR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_lnVR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnVRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_lnVR[[i]] <- rma.mv(yi = data_species_leave$lnVR,
                                              V = VCV_leave_species_out_lnVR[[i]],
                                              random = list(~1 | study_id,
                                                            ~1 | assay_id,
                                                            ~1 | species_latin,
                                                            ~1 | pesticide),
                                              method = "REML", 
                                              test = "t",
                                              data = data_species_leave,
                                              sparse = TRUE)
} 

results.leave_species_out_model_lnVR <- as.data.frame(cbind(
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_lnVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_lnVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_species_out_model_lnVR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_lnVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_species_out_lnVR_forest_plot <- ggplot(results.leave_species_out_model_lnVR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_one_species_out_lnVR_forest_plot)


```

### *Leave one pesticide out*

#### Intercept only model (lnRR) 
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_lnRR <- list()
VCV_leave_pesticide_out_lnRR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnRRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_lnRR[[i]] <- rma.mv(yi = data_pesticide_leave$lnRR,
                                                V = VCV_leave_pesticide_out_lnRR[[i]],
                                                random = list(~1 | study_id,
                                                              ~1 | assay_id,
                                                              ~1 | species_latin,
                                                              ~1 | pesticide),
                                                method = "REML", 
                                                test = "t",
                                                data = data_pesticide_leave,
                                                sparse = TRUE)
} 

results.leave_pesticide_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_pesticide_out_model_lnRR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_pesticide_out_lnRR_forest_plot <- ggplot(results.leave_pesticide_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_one_pesticide_out_lnRR_forest_plot)


```

#### Intercept only model (lnVR)
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_lnVR <- list()
VCV_leave_pesticide_out_lnVR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_lnVR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnVRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_lnVR[[i]] <- rma.mv(yi = data_pesticide_leave$lnVR,
                                                V = VCV_leave_pesticide_out_lnVR[[i]],
                                                random = list(~1 | study_id,
                                                              ~1 | assay_id,
                                                              ~1 | species_latin,
                                                              ~1 | pesticide),
                                                method = "REML", 
                                                test = "t",
                                                data = data_pesticide_leave,
                                                sparse = TRUE)
} 

results.leave_pesticide_out_model_lnVR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_lnVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_lnVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_pesticide_out_model_lnVR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_lnVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_pesticide_out_lnVR_forest_plot <- ggplot(results.leave_pesticide_out_model_lnVR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_one_pesticide_out_lnVR_forest_plot)

```

## *Alternative effect sizes*

### Intercept only model (SMD)
```{r}
# Model
SMD_intercept_only <- rma.mv(yi = SMD,
                              V = SMDVCV,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary statistics 
summary(SMD_intercept_only)

mod_results(SMD_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(SMD_intercept_only)
  
# orchaRd plot
orchaRd::orchard_plot(SMD_intercept_only,
             group = "study_id",
             xlab = "SMDH",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnCVR)
```{r}
# Model
lnCVR_intercept_only <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)
  

# Summary results
summary(lnCVR_intercept_only)

mod_results(lnCVR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnCVR_intercept_only)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_intercept_only,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

## *Alternative variance-covariance matrices*

### Intercept only model (lnRR)
```{r}
# Model
lnRR_intercept_only2 <- rma.mv(yi = lnRR,
                              V = lnRRVCV2,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary statistics 
summary(lnRR_intercept_only2)

mod_results(lnRR_intercept_only2, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only2)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only2,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnVR)
```{r}
# Model
lnVR_intercept_only2 <- rma.mv(yi = lnVR,
                               V = lnVRVCV2,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = TRUE)
  

# Summary results
summary(lnVR_intercept_only2)

mod_results(lnVR_intercept_only2, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnVR_intercept_only2)

# orchaRd plot
orchaRd::orchard_plot(lnVR_intercept_only2,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 

```

## *Leave studies with imputed errors out*

### Intercept only model (lnRR) 
```{r}
data_no_imputed <- data %>%  filter(data$control_imputed == "No")

lnRRVCV_no_imputed <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_no_imputed, rho = 0.5)

# Model
lnRR_intercept_only_no_imputed <- rma.mv(yi = lnRR,
                              V = lnRRVCV_no_imputed,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data_no_imputed,
                              sparse = T)

# Summary statistics 
summary(lnRR_intercept_only_no_imputed)

mod_results(lnRR_intercept_only_no_imputed, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only_no_imputed)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only_no_imputed,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnVR) 
```{r}
# Calculate the variance-covariance matrix for lnVR
lnVRVCV_no_imputed <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data_no_imputed, rho = 0.5)

# Model
lnVR_intercept_only_no_imputed <- rma.mv(yi = lnVR,
                              V = lnVRVCV_no_imputed,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data_no_imputed,
                              sparse = TRUE)

# Summary statistics 
summary(lnVR_intercept_only_no_imputed)

mod_results(lnVR_intercept_only_no_imputed, mod = "1", data = data_no_imputed, group = "study_id")  # For prediction intervals

i2_ml(lnVR_intercept_only_no_imputed)
  
# orchaRd plot
orchaRd::orchard_plot(lnVR_intercept_only_no_imputed,
             group = "study_id",
             xlab = "lnVR",
             data = data_no_imputed,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```


## *Create models with only Zebrafish*

### Intercept only models (lnRR)
```{r}

data_zebrafish <- data %>% filter(species_english == "zebrafish")

lnRRVCV_zebrafish <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_zebrafish, rho = 0.5)

# Model
lnRR_intercept_only_zebrafish <- rma.mv(yi = lnRR,
                                        V = lnRRVCV_zebrafish,
                                        random = list(~1 | study_id,
                                                      ~1 | assay_id,
                                                      ~1 | species_latin,
                                                      ~1 | pesticide),
                                        method = "REML",
                                        test = "t", 
                                        data = data_zebrafish,
                                        sparse = T)

# Summary statistics 
summary(lnRR_intercept_only_zebrafish)

mod_results(lnRR_intercept_only_zebrafish, mod = "1", data = data_zebrafish, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only_zebrafish)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only_zebrafish,
                      group = "study_id",
                      xlab = "lnRR",
                      data = data_zebrafish,
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)


```

### Intercept only models (lnVR)
```{r}
# Calculate the variance-covariance matrix for lnVR
lnVRVCV_zebrafish <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data_zebrafish, rho = 0.5)

# Model
lnVR_intercept_only_zebrafish <- rma.mv(yi = lnVR,
                                        V = lnVRVCV_zebrafish,
                                        random = list(~1 | study_id,
                                                      ~1 | assay_id,
                                                      ~1 | species_latin,
                                                      ~1 | pesticide),
                                        method = "REML",
                                        test = "t", 
                                        data = data_zebrafish,
                                        sparse = TRUE)

# Summary statistics 
summary(lnVR_intercept_only_zebrafish)

mod_results(lnVR_intercept_only_zebrafish, mod = "1", data = data_zebrafish, group = "study_id")  # For prediction intervals

i2_ml(lnVR_intercept_only_zebrafish)
  
# orchaRd plot
orchaRd::orchard_plot(lnVR_intercept_only_zebrafish,
                      group = "study_id",
                      xlab = "lnVR",
                      data = data_zebrafish,
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)

```

### Moderate by behavioural class (lnRR) only including studies using zebrafish
```{r}
# Model
lnRR_mod_behaviour_class_zebrafish <- rma.mv(yi = lnRR,
                                             V = lnRRVCV_zebrafish,
                                             random = list(~1 | study_id,
                                                           ~1 | assay_id,
                                                           ~1 | species_latin,
                                                           ~1 | pesticide),
                                             mods = ~behaviour_measured_standardised -1,
                                             method = "REML",
                                             test = "t", 
                                             data = data_zebrafish,
                                             sparse = T)

# Summary results
summary(lnRR_mod_behaviour_class_zebrafish)

mod_results(lnRR_mod_behaviour_class_zebrafish, mod = "behaviour_measured_standardised", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_behaviour_class_zebrafish,
                      group = "pesticide_chemical_class", 
                      xlab = "lnRR",
                      data = data_zebrafish,
                      mod = "behaviour_measured_standardised",
                      k.pos = "right",
                      colour = TRUE,
                      fill = FALSE)
```

### Moderate by behavioural class (lnVR)
```{r}
# Model
lnVR_mod_behaviour_class_zebrafish <- rma.mv(yi = lnVR,
                                             V = lnVRVCV_zebrafish,
                                             random = list(~1 | study_id,
                                                           ~1 | assay_id,
                                                           ~1 | species_latin,
                                                           ~1 | pesticide),
                                             mods = ~behaviour_measured_standardised -1,
                                             method = "REML",
                                             test = "t", 
                                             data = data_zebrafish,
                                             sparse = TRUE)

# Summary results
summary(lnVR_mod_behaviour_class_zebrafish)

mod_results(lnVR_mod_behaviour_class_zebrafish, mod = "behaviour_measured_standardised", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_behaviour_class_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_behaviour_class_zebrafish,
                      group = "pesticide_chemical_class", 
                      xlab = "lnVR",
                      data = data_zebrafish,
                      mod = "behaviour_measured_standardised",
                      k.pos = "right",
                      colour = TRUE,
                      fill = FALSE)

```

### Moderate by pesticide chemical class (lnRR)
```{r}
# Model
lnRR_mod_pesticide_zebrafish <- rma.mv(yi = lnRR,
                                       V = lnRRVCV_zebrafish,
                                       random = list(~1 | study_id,
                                                     ~1 | assay_id,
                                                     ~1 | species_latin,
                                                     ~1 | pesticide),
                                       mods = ~pesticide_chemical_class -1,
                                       method = "REML",
                                       test = "t", 
                                       data = data_zebrafish,
                                       sparse = TRUE)

# Summary results
summary(lnRR_mod_pesticide_zebrafish)

mod_results(lnRR_mod_pesticide_zebrafish, mod = "pesticide_chemical_class", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_pesticide_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_pesticide_zebrafish,
                      group = "study_id", 
                      xlab = "lnRR",
                      data = data_zebrafish,
                      mod = "pesticide_chemical_class",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)

```

### Moderate by pesticide chemcial class (lnVR)
```{r}
# Model
lnVR_mod_pesticide_zebrafish <- rma.mv(yi = lnVR,
                                       V = lnVRVCV_zebrafish,
                                       random = list(~1 | study_id,
                                                     ~1 | assay_id,
                                                     ~1 | species_latin,
                                                     ~1 | pesticide),
                                       mods = ~pesticide_chemical_class -1,
                                       method = "REML",
                                       test = "t", 
                                       data = data_zebrafish,
                                       sparse = TRUE)

# Summary results
summary(lnVR_mod_pesticide_zebrafish)

mod_results(lnVR_mod_pesticide_zebrafish, mod = "pesticide_chemical_class", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_pesticide_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_pesticide_zebrafish,
                      group = "study_id", 
                      xlab = "lnVR",
                      data = data_zebrafish,
                      mod = "pesticide_chemical_class",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)
```

```{r}
sessionInfo()
```

