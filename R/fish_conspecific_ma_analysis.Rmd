---
title: "The impacts of pesticide exposure on fish conspecific behavioural interactions: a systematic review and meta-analysis"
author: Kyle Morrison, Aneesh Bose, Rhiannon Eastment, Jack Manera, Gabriel Melhado, Marcus
  Michelangeli, Shiho Ozeki, Bob Wong, Yefeng Yang, Malgorzata Lagisz, Shinichi Nakagawa
date: "latest update: `r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    code_download: true
    theme: flatly   # Options: cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, yeti
    highlight: monochrome  # Options: default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, textmate
editor_options: 
  chunk_output_type: console

---
```{r setup, include = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE,
  echo=TRUE
)
```

# **Load packages and data**

## *Load packages*

```{r}
rm(list = ls())

pacman::p_load(tidyverse,
               here,
               kableExtra,
               magrittr, 
               patchwork,
               metafor,
               metagear,
               ape,
               rotl,
               orchaRd,
               clubSandwich)

```

## Load Data
```{r}
data <- read_csv(here("data", "fish_conspecific_behaviour_ma_data.csv"), skip = 0)

# Format ID variables as characters
data <- mutate_at(data, 
                  vars(study_id, 
                       exp_id, 
                       exp2_id, 
                       assay_id, 
                       assay2_id), 
                       as.character)
# Table of the dataset
 kable(data, "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "800px")


# Summary of the data set
kable(summary(data), "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "500px")
```


# **Data exploration and reporting of methodological items**
## Main text Figure 1
b) A bubble plot showing the number of effect sizes of each pesticide class per conspecific interaction behaviour described
c) A bar chart showing the total number of effect sizes per species
```{r,fig.width=8, fig.height=13}
# Summarize data by grouping on pesticide chemical class and behavior measured, then count entries.
pc_cb_summary <- data %>% 
  group_by(pesticide_chemical_class, behaviour_measured_standardised) %>% 
  summarise(n = n(), .groups = "drop")

# Determine the top 9 pesticide classes based on the number of records.
top_pesticide_class <- pc_cb_summary %>%
  group_by(pesticide_chemical_class) %>%
  summarise(total_count = sum(n)) %>%
  top_n(9, total_count) %>%
  pull(pesticide_chemical_class)

# Adjust category names to 'Other pesticide classes' for those pesticide classes not in the top 9
pc_cb_summary_filtered <- pc_cb_summary %>%
  mutate(pesticide_chemical_class = ifelse(pesticide_chemical_class %in% top_pesticide_class,
                                           pesticide_chemical_class,
                                           "Other Pesticide Classes")) %>%
  group_by(pesticide_chemical_class, behaviour_measured_standardised) %>%
  summarise(n = sum(n), .groups = "drop")

# Create the bubble plot
behaviour_pesticide_class_bubble_plot <- pc_cb_summary_filtered %>%
   ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(pesticide_chemical_class), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) +
  scale_size_continuous(range = c(5, 20)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"))  +
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the number of effect sizes",
       x = "Behaviour Measured",
       y = "Pesticide Chemical Class",
       tag = "B")

# Group data by species, count entries, and drop groups post-summary.
sp_summary <- data %>% 
  group_by(species_english) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate proportion and percentage of total counts for each species.
species_pct <- sp_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create the bar plot
species_effect_size_count_bar_plot <- sp_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(species_english), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  geom_text(aes(label = ifelse(n < 9, "", n), x = n / 2, y = reorder(str_to_title(species_english), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = species_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sp_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total number of effect size estimates",
       y = "Species",
       tag = "C")

# Combine both plots into a single figure.
main_text_figure_1 <- behaviour_pesticide_class_bubble_plot / species_effect_size_count_bar_plot

print(main_text_figure_1)
# ggsave(here("figures", "main_text_figure_1.pdf"), width = 8, height = 13, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "main_text_figure_1.jpg"), width = 8, height = 13, units = "cm", scale = 2, dpi = 800)
```

# Supplementary figure xx
A bubble plot showing the number of effect sizes of each pesticide per conspecific interaction behaviour described
```{r,fig.width=8, fig.height=8}
# Group data by species, count entries, and drop groups post-summary.
p_cb_summary <- data %>%
  group_by(pesticide, behaviour_measured_standardised) %>%
  summarise(
    n = n(),
    pesticide_chemical_class = first(pesticide_chemical_class),
    .groups = "drop"
  )
# Determine the top 8 pesticide classes based on the number of records.
top_pesticides <- p_cb_summary %>%
  group_by(pesticide, behaviour_measured_standardised) %>%
  summarise(total_count = sum(n), .groups = "drop") %>%
  top_n(20, total_count) %>%
  pull(pesticide)

# Adjust category names to 'Other Pesticides' for all but the top pesticide, then re-summarize.
# p_cb_summary_filtered <- p_cb_summary %>%
# mutate(pesticide = ifelse(pesticide %in% top_pesticides,
#                                          pesticide,
#                                          "Other Pesticides")) %>%
#  group_by(pesticide, behaviour_measured_standardised) %>%
#  summarise(n = sum(n), .groups = "drop")


# Create the bubble plot for the behaviours assessed per pesticide (effect size as count)
behaviour_pesticide_bubble_plot <- p_cb_summary %>% # can add _filtered if needed
   ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(pesticide), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[5]) +
  scale_size_continuous(range = c(4, 20)) +
  theme_bw() +
  guides(size = "none") +
theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the number of effect sizes",
       x = "Behaviour Measured",
       y = "Pesticide Chemical Class") +
      scale_y_discrete(labels = function(x) ifelse(x %in% c("Ddt", "Dca", "Dcpmu"), toupper(x), x))

print(behaviour_pesticide_bubble_plot)

# ggsave(here("figures", "behaviour_pesticide_bubble_plot.pdf"), width = 8, height = 12, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "behaviour_pesticide_bubble_plot.jpg"), width = 8, height = 12, units = "cm", scale = 2, dpi = 800)
```

```{r,fig.width=8, fig.height=6}
# Group data by species, count entries, and drop groups post-summary.
species_summary <- data %>%
  group_by(species_english, behaviour_measured_standardised) %>%
  summarise(
    n = n(),
    pesticide_chemical_class = first(pesticide_chemical_class),
    .groups = "drop"
  )

# Determine the top 20 species based on the number of records.
top_species <- species_summary %>%
  group_by(species_english, behaviour_measured_standardised) %>%
  summarise(total_count = sum(n), .groups = "drop") %>%
  top_n(20, total_count) %>%
  pull(species_english)

# Adjust category names to 'Other' for all but the top species, then re-summarize.
# species_summary_filtered <- species_summary %>%
#   mutate(species_english = ifelse(species_english %in% top_species,
#                                   species_english,
#                                   "Other Species")) %>%
#   group_by(species_english, behaviour_measured_standardised) %>%
#   summarise(n = sum(n), .groups = "drop")

# Create the bubble plot the behaviours assessed per species (number of effect size as count)
behaviour_species_bubble_plot <- species_summary %>% # can add _filtered if needed
  ggplot(aes(x = fct_rev(fct_reorder(str_to_title(behaviour_measured_standardised), n, .fun = 'sum')),
             y = fct_reorder(str_to_title(species_english), n, .fun = 'sum'),
             size = n)) +
  geom_point(alpha = 0.5, color = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  scale_size_continuous(range = c(8, 25)) +
  theme_bw() +
  guides(size = "none") +
theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) + 
  geom_text(aes(label = as.character(n)), size = 4, color = "gray10") +
  labs(caption = "The value in each cell is the number of effect sizes",
       x = "Behaviour Measured",
       y = "Species") +
  scale_color_brewer(palette = "Dark2", name = "Chemical Class")

print(behaviour_species_bubble_plot)

# ggsave(here("figures", "behaviour_species_bubble_plot.pdf"), width = 8, height = 6, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "behaviour_species_bubble_plot.jpg"), width = 8, height = 6, units = "cm", scale = 2, dpi = 800)
```

## Supplementary figure x
A bar chart showing the reporting of the source of fish used in the literature
```{r,fig.width=10, fig.height=5}
# Extracts unique records from the dataset based on 'study_id', retaining all other associated data.
data_study <- data %>%
  distinct(study_id, .keep_all = TRUE) 

# Groups the filtered data by 'source of fish' and counts the number of studies per source, removing grouping afterwards.
source_summary <- data_study %>% 
  group_by(source) %>% 
  summarise(n = n(), .groups = "drop")

# Calculates the proportion and percentage of total studies for each source of fish.
source_pct <- source_summary %>% 
  mutate(proportion = n / sum(n),  # number of studies
         percentage = proportion * 100)

# Create the bar plot for the source of fish study count
fish_source_study_count_bar_plot <- source_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(source), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(source), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = source_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(source_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of studies",
       y = "Source of fish") 

print(fish_source_study_count_bar_plot)

# ggsave(here("figures", "fish_source_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "fish_source_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Figure x
A bar chart showing the sex of fish used in the literature
```{r,fig.width=10, fig.height=5}
# Group data by 'sex of fish' and count entries, then drop grouping for further analysis.
sex_summary <- data_study %>% 
  group_by(sex) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate proportions and percentages of total studies for each sex.
sex_pct <- sex_summary %>% 
  mutate(proportion = n / sum(n),  
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies per sex, with annotations for counts and percentages.
fish_sex_study_count_bar_plot <- sex_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(sex), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(sex), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = sex_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sex_summary$n) * 1.2)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of studies",
       y = "Sex of fish")

print(fish_sex_study_count_bar_plot)

# ggsave(here("figures", "fish_sex_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "fish_sex_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Supplementary Figure x 
A bar plot showing the control solvents used in the literature
```{r,fig.width=10, fig.height=5}
# Group data by 'control solvent' and count entries, then drop the group structure for further analysis.
solvent_summary <- data_study %>% 
  group_by(control_solvent) %>% 
  summarise(n = n(), .groups = "drop")

# Calculate the proportion and percentage of total studies for each control solvent.
solvent_pct <- solvent_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies per control solvent, annotated with counts and percentages.
control_solvent_study_count_bar_plot <- solvent_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(control_solvent), n))) + 
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[3]) +
  geom_text(aes(label = n, x = n / 2, y = reorder(str_to_title(control_solvent), n)), hjust = 0.5, size = 4, color = "black") +
  geom_text(data = solvent_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(solvent_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of studies",
       x = "Total number of studies",
       y = "Control Solvent") +
  scale_y_discrete(labels = function(x) ifelse(x == "Dmso", toupper(x), ifelse(x == "Dtnb", toupper(x), x)))

print(control_solvent_study_count_bar_plot)

# ggsave(here("figures", "control_solvent_study_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "control_solvent_study_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Supplementary Figure x
A bar plot showing the behavioural assays used to quantify soliality in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "sociality" in behaviour_measure_standardised
sociality_data <- data %>% 
  filter(grepl("sociality", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardized and count occurrences
sociality_assay_summary <- sociality_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each control solvent
sociality_assay_pct <- sociality_assay_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on aggression, annotated with counts and percentages.
sociality_assay_effect_size_count_bar_plot <- sociality_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[5]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = sociality_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(sociality_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Sociality Assay")

print(sociality_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "sociality_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "sociality_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Supplementary Figure x
A bar plot showing the behavioural assays used to quantify aggression in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "aggression" in behaviour_measure_standardised
aggression_data <- data %>% 
  filter(grepl("aggression", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
aggression_assay_summary <- aggression_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
aggression_assay_pct <- aggression_assay_summary %>% 
  mutate(proportion = n / sum(n), 
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on aggression, annotated with counts and percentages.
aggression_assay_effect_size_count_bar_plot <- aggression_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[6]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = aggression_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(aggression_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Aggression Assay")

print(aggression_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "aggression_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "aggression_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Supplementary Figure x
A bar plot showing the behavioural assays used to quantify courtship in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "courtship" in behaviour_measure_standardised
courtship_data <- data %>% 
  filter(grepl("courtship", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
courtship_assay_summary <- courtship_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
courtship_assay_pct <- courtship_assay_summary %>% 
  mutate(proportion = n / sum(n), # Adjust total number of observations
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on courtship, annotated with counts and percentages.
courtship_assay_effect_size_count_bar_plot <- courtship_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_title(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[6]) +
  geom_text(aes(label = ifelse(n < 0, "", n), x = n / 2, y = reorder(str_to_title(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = courtship_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(courtship_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Courtship Assay")

print(courtship_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "courtship_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "courtship_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

## Supplementary Figure x
A bar plot showing the behavioural assays used to quantify collective behaviour (i.e., behaviours measure at collective level) in the literature
```{r,fig.width=10, fig.height=5}
# Filter data for entries containing "collective behaviour" in behaviour_measure_standardised
collective_behaviour_data <- data %>% 
  filter(grepl("collective behaviour", behaviour_measured_standardised, ignore.case = TRUE))

# Group data by behavioural_assay_standardised and count occurrences
collective_behaviour_assay_summary <- collective_behaviour_data %>% 
  group_by(behavioural_assay_standardised) %>%
  summarise(n = n(), .groups = "drop")

# Calculate proportion of effect sizes for each behavioural assay
collective_behaviour_assay_pct <- collective_behaviour_assay_summary %>% 
  mutate(proportion = n / sum(n), # Adjust total number of observations
         percentage = proportion * 100)

# Create a bar plot visualizing the number of studies quantifying pesticide impacts on collective behaviour, annotated with counts and percentages.
collective_behaviour_assay_effect_size_count_bar_plot <- collective_behaviour_assay_summary %>%
  ggplot(aes(x = n, y = reorder(str_to_sentence(behavioural_assay_standardised), n))) +
  geom_bar(stat = "identity", width = 0.8, alpha = 0.5, fill = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[7]) +
  geom_text(aes(label = ifelse(n < 9, "", n), x = n / 2, y = reorder(str_to_sentence(behavioural_assay_standardised), n)), 
            hjust = 0.5, size = 4, color = "black") +
  geom_text(data = collective_behaviour_assay_pct, aes(label = paste0("(", round(percentage, 1), "%)"), x = n),
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(collective_behaviour_assay_summary$n) * 1.3)) +
  theme_bw() +
  guides(size = "none") +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "The value in each bar is the total number of effect sizes",
       x = "Total Number of Effect Sizes",
       y = "Collective Behaviour Assay")

print(collective_behaviour_assay_effect_size_count_bar_plot)

# ggsave(here("figures", "collective_behaviour_assay_effect_size_count_bar_plot.pdf"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "collective_behaviour_assay_effect_size_count_bar_plot.jpg"), width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```

# Supplentmentary Figure x
A box and violin plot showing the distribution of pesticide dosages used in the literature
```{r}
# making dosages consistent for dosage comparisons
data_dosage <- data %>%
  filter(dosage != "not reported") %>% 
filter(dosage_unit != "not reported") %>% 
filter(!dosage_unit %in% c("nm", "um", "nM")) %>%
  mutate(dosage = as.numeric(dosage),
         dosage_unit = as.character(dosage_unit),
         dosage_unit_consistent = case_when(
           dosage_unit == "mg/L" ~ "ug/L", 
           dosage_unit == "ng/L" ~ "ug/L",
           dosage_unit == "g/L" ~ "ug/L",
           dosage_unit == "ppb" ~ "ug/L", 
           dosage_unit == "ppm" ~ "ug/L", 
           TRUE ~ dosage_unit),
         dosage_convert_ugL = case_when(
           dosage_unit == "mg/L" ~ dosage * 1000,
           dosage_unit == "ng/L" ~ dosage / 1000,
           dosage_unit == "g/L" ~ dosage/1000000,
           dosage_unit == "ppm" ~ dosage*1000, 
           TRUE ~ dosage))

# Summary table for the dosage converted
summary_data_dosage <- summary(data_dosage$dosage_convert_ugL)

# Filter the data for dosage_convert_ugL less than 5000
filtered_data_dosage <- data_dosage %>%
  filter(dosage_convert_ugL < 3000)

# Create the violin plot
pesticide_dosage_violin_plot <- ggplot(filtered_data_dosage, aes(y = dosage_unit_consistent, x = dosage_convert_ugL)) +
    geom_violin(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.4, color = NA, trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white", color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], outlier.shape = NA) +
  geom_jitter(width = 0.3, height = 0.09, color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.8) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_blank(),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Plot filtered for less than 3000 ug/L\nMedian = 12, 1st Quartile = 1, 3rd Quartile = 500",
       y = "Dosage Unit [ug/L]")

print(pesticide_dosage_violin_plot)

# ggsave(here("figures", "pesticide_dosage_violin_plot.pdf"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "pesticide_dosage_violin_plot.jpg"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```


## Supplementary Figure x
A box and violin plot the distribution of durations of pesticide exposure 
```{r}
data_duration <- data %>% 
  filter(!is.na(duration), duration != "not reported") %>%
  mutate(duration = as.numeric(duration),
         duration_unit = as.character(duration_unit),
           duration_unit_consistent = case_when(
          duration_unit == "minutes" ~ "hours",
          duration_unit == "days" ~ "hours",
          duration_unit == "weeks" ~ "hours",
           TRUE ~ duration_unit),
 duration_convert = case_when(
    duration_unit == "minutes" ~ duration/ 60, 
    duration_unit == "days" ~ duration*24, 
    duration_unit == "weeks" ~ duration*168,
    TRUE ~ duration))

summary(data_duration$duration_convert)

# Create the violin plot for duration
pesticide_duration_violin_plot <- ggplot(data_duration, aes(y = duration_unit_consistent, x = duration_convert)) +
  geom_violin(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.4, color = NA, trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white", color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], outlier.shape = NA) +
  geom_jitter(width = 0.3, height = 0.09, color = RColorBrewer::brewer.pal(n = 8, name = "Set2")[1], alpha = 0.8) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_blank(),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_blank(),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Median = 336, 1st Quartile = 96, 3rd Quartile = 960",
       y = "Duration [hours]")

print(pesticide_duration_violin_plot)

# ggsave(here("figures", "pesticide_duration_violin_plot.pdf"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
# ggsave(here("figures", "pesticide_duration_violin_plot.jpg"), plot = dosage_violin_plot, width = 10, height = 5, units = "cm", scale = 2, dpi = 800)
```


# **Impute missing standard deviations and calculate effect size estimates**
We imputed the missing standard deviations using the formula provided in section 13.1 (p. 199) of the Handbook of Meta-analysis in Ecology and Evolution (Koricheva, Gurevitch, and Mengersen, 2013).

To ensure consistency in treatments subjected to repeated stepwise multiple comparisons (i.e., the same data used multiple times to calculate different effect sizes), we maintained the same imputed standard deviations (or standard errors) for the repeated data.

### Find SD/Mean ratio
A bar plot showing the SD/Mean ratio of the control and treatment groups in each primary study
```{r}
sd_mean_ratio <- data %>%
  mutate(
    control_sd = as.numeric(control_sd),
    treatment_sd = as.numeric(treatment_sd)
  ) %>%
  group_by(study_id) %>%
  mutate(
    within_study_control_mean = mean(control_mean, na.rm = TRUE),
    within_study_treatment_mean = mean(treatment_mean, na.rm = TRUE),
    within_study_control_sd = mean(control_sd, na.rm = TRUE),
    within_study_treatment_sd = mean(treatment_sd, na.rm = TRUE),
    sd_mean_ratio_control = within_study_control_sd / within_study_control_mean,
    sd_mean_ratio_treatment = within_study_treatment_sd / within_study_treatment_mean
  )

sd_mean_ratio_bar_plot <- sd_mean_ratio %>% 
  ggplot() + 
  geom_histogram(aes(x = sd_mean_ratio_control), fill = "blue", alpha = 0.4) + 
  geom_histogram(aes(x = sd_mean_ratio_treatment), fill = "red", alpha = 0.4) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  guides(size = "none") +
  theme(
    legend.position = "none",
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    plot.caption = element_text(size = 10, color = "gray10", face = "italic")
  ) +
  labs(
    caption = "Red = Control, Blue = Treatment, Purple = Both\nThe value in each bar is the total number of effect sizes",
    x = "SD/Mean Ratio",
    y = "Frequency"
  )

print(sd_mean_ratio_bar_plot)

```

## Plot and imputed missing standard deviations
```{r}
# Indicate which individuals are used in more than one control or treatment to calculate sampling variances of non-independent observations differently. 
data_shared_indiv <- group_by(data, exp_id ) %>% 
  summarise(number_treatment= n())
data <- left_join(data, data_shared_indiv, by = "exp_id")


# Calculate the within and between study impacts of pesticides on fish social behaviour
data <- data %>% 
  group_by(study_id) %>% 
  mutate(
    control_sd = as.numeric(control_sd),
    treatment_sd = as.numeric(treatment_sd)) %>%
  group_by(study_id) %>%
  mutate(
    within_study_control_mean = mean(control_mean, na.rm = TRUE),
    within_study_treatment_mean = mean(treatment_mean, na.rm = TRUE),
    within_study_control_sd = mean(control_sd, na.rm = TRUE),
    within_study_treatment_sd = mean(treatment_sd, na.rm = TRUE),
    sd_mean_ratio_control = within_study_control_sd / within_study_control_mean,
    sd_mean_ratio_treatment = within_study_treatment_sd / within_study_treatment_mean) %>% 
  ungroup() %>% 
  mutate(between_study_control_mean=mean(within_study_control_mean, na.rm=T),  
         between_study_treatment_mean=mean(within_study_treatment_mean, na.rm=T),
         between_study_control_sd=mean(within_study_control_sd, na.rm=T), 
         between_study_treatment_sd=mean(within_study_treatment_sd, na.rm=T)) 

data %>% select(control_sd, treatment_sd) %>% impute_missingness() # Missing SD == 3.9%, 36 imputations needed 

data <- as.data.frame(data) # convert into dataframe
data <- impute_SD(data, 
                       columnSDnames = c("control_sd", "treatment_sd"), 
                       columnXnames = c("control_mean", "treatment_mean"), 
                       method = "Bracken1992")


# label missing location
data$control_sd_report <- ifelse(is.na(data$control_sd),"Yes","No")
data$treatment_sd_report <- ifelse(is.na(data$treatment_sd),"Yes","No")

# Convert sd columns to log10 and create a combined dataframe for plotting
data_long <- data %>%
  mutate(log_control_sd = log10(control_sd),
         log_treatment_sd = log10(treatment_sd)) %>%
  pivot_longer(cols = c(log_control_sd, log_treatment_sd), 
               names_to = "type", 
               values_to = "log_sd") %>%
  mutate(reported = ifelse(type == "log_control_sd", control_sd_report, treatment_sd_report))

# Create the plot
imputed_sd_plot <- ggplot(data_long, aes(x = factor(study_id), y = log_sd, color = reported)) +
  geom_point(size = 2, alpha = 0.5) +
  scale_color_manual(values = RColorBrewer::brewer.pal(n = 8, name = "Dark2")[c(1, 2)]) +
  theme_bw() +
  theme(
    legend.position = "none", 
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5) 
  ) +
  labs(
    caption = "Points with 'red' indicate missing standard deviations that were imputed",
    x = "Study ID",
    y = "Log10(SD Value)",
    color = "Reported"
  )

# Print the plot
print(imputed_sd_plot)
```

## **Calculate effect sizes and sampling variances**
```{r}
# Make sure all data is numeric 
data <- data  %>%
  mutate(
    treatment_mean = as.numeric(treatment_mean),
    treatment_sd = as.numeric(treatment_sd),
    treatment_n = as.numeric(treatment_n),
    control_mean = as.numeric(control_mean),
    control_sd = as.numeric(control_sd),
    control_n = as.numeric(control_n)
  )
# Calculate log response ratio (lnRR)
lnRR <- escalc(measure = "ROM", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate log coefficient variation ratio (lnCVR)
lnCVR <- escalc(measure = "CVR", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate the standardised mean difference for sensitivity analysis
SMD <- escalc(measure = "SMD", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate the standardised mean difference with heteroscedacity for sensitivity analysis
SMDH <- escalc(measure = "SMDH", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Calculate log variation ratio (lnVR)
lnVR <- escalc(measure = "VR", 
               m1i = treatment_mean, sd1i = treatment_sd, n1i = treatment_n, 
               m2i = control_mean, sd2i = control_sd, n2i = control_n, 
               data = data)

# Summary statistics of effect size estimates
effect_size_summaries <- list(
  lnRR = summary(lnRR$yi),
  lnCVR = summary(lnCVR$yi),
  SMD = summary(SMD$yi),
  SMDH = summary(SMDH$yi),
  VR = summary(lnVR$yi)
)

# Summary statistics of sampling variances
sampling_variance_summaries <- list(
  lnRR = summary(lnRR$vi),
  lnCVR = summary(lnCVR$vi),
  SMD = summary(SMD$vi),
  SMDH = summary(SMDH$vi),
  VR = summary(lnVR$vi)
)

# Calculate precision for each effect size estimate with checks
lnRR$precision <- ifelse(lnRR$vi > 0, 1 / sqrt(lnRR$vi), NA)
lnCVR$precision <- ifelse(lnCVR$vi > 0, 1 / sqrt(lnCVR$vi), NA)
SMD$precision <- ifelse(SMD$vi > 0, 1 / sqrt(SMD$vi), NA)
SMDH$precision <- ifelse(SMDH$vi > 0, 1 / sqrt(SMDH$vi), NA)
lnVR$precision <- ifelse(lnVR$vi > 0, 1 / sqrt(lnVR$vi), NA)


# Merge each of the effect size with precision
effect_size_metrics_set <- data.frame(
  lnRR = lnRR$yi, lnRRv = lnRR$vi, lnRR_precision = lnRR$precision,
  lnVR = lnVR$yi, lnVRv = lnVR$vi, lnVR_precision = lnVR$precision,
  lnCVR = lnCVR$yi, lnCVRv = lnCVR$vi, lnCVR_precision = lnCVR$precision,
  SMD = SMD$yi, SMDv = SMD$vi, SMD_precision = SMD$precision,
  SMDH = SMDH$yi, SMDHv = SMDH$vi, SMDH_precision = SMDH$precision, control_imputed = data$control_sd_report, treatment_imputed = data$treatment_sd_report)



 # Bind the effect size metrics set to the main data
data <- cbind(data, effect_size_metrics_set)



# Check if `effect_direction` is "change" and not NA, then multiply `lnRR` by -1; otherwise, keep original `lnRR`
data$lnRR <- ifelse(!is.na(data$effect_direction) & data$effect_direction == "change", 
                    -1 * data$lnRR, 
                    data$lnRR)


# Select specific columns including the new precision columns
effect_size_metrics_set_kable <- data[, which(colnames(data) %in% c(
  "study_id", "exp_id", "assay_id", "species_english", "pesticide", "behaviour_assay","effect_direction",
  "lnRR", "lnRRv", "lnRR_precision", 
  "lnCVR", "lnCVRv", "lnCVR_precision", 
  "lnVR", "lnVRv", "lnVR_precision", 
  "SMD", "SMDv", "SMD_precision", 
  "SMDH", "SMDHv", "SMDH_precision",
  "control_imputed", "treatment_imputed"
))] %>% dfround(digits = 3)


# Table of the effect sizes
 kable(effect_size_metrics_set_kable, "html") %>%
    kable_styling("bordered", position = "left") %>%
    scroll_box(width = "250%", height = "800px")

# Plot the distribution of effect size estimates (lnRR)
lnRR_dist_plot <- effect_size_metrics_set_kable %>%
  ggplot(aes(lnRR)) +
  geom_histogram(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[2], col = "black", binwidth = 0.1, alpha = 0.4) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Distribution of Effect Size Estimates (lnRR)",
       x = "lnRR",
       y = "Frequency")

print(lnRR_dist_plot)


 # Plot the distribution of effect size estimates (lnCVR)
lnCVR_dist_plot <- effect_size_metrics_set_kable %>%
  ggplot(aes(lnCVR)) +
  geom_histogram(fill = RColorBrewer::brewer.pal(n = 8, name = "Set2")[3], col = "black", binwidth = 0.1, alpha = 0.4) +
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks = element_line(color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic")) +
  labs(caption = "Distribution of Effect Size Estimates (lnCVR)",
       x = "lnCVR",
       y = "Frequency")

print(lnCVR_dist_plot)
```

## **Dependent effect size estimates**

### Create phylogentic tree
Using *rotl* package to retrieve synthetic species tree from Open Tree of Life
Rotl is an R package (https://peerj.com/preprints/1471/) allowing access to synthetic phylogenetic tree available at Open Tree of Life database (https://opentreeoflife.org/). 
```{r}
data <- as.data.frame(data)

data$species_latin = as.factor(data$species_latin)

taxa <- tnrs_match_names(names = levels(data$species_latin), context = "Animals")  # Match species names to the Open Tree of Life taxonomy

kable(taxa)  # Display matched species, ensuring each species has a unique match in the Open Tree of Life

taxa$unique_name <- gsub(" ", "_", taxa$unique_name)  # Replace spaces in species names with underscores

phylo_tree <- tol_induced_subtree(ott_ids = taxa$ott_id, label_format = "name")  # Generate a phylogenetic tree based on the Open Tree of Life taxonomy

ott_in_tree <- ott_id(taxa)[is_in_tree(ott_id(taxa))]  # Ensure all identifiers are present in the taxonomy

phylo_tree <- tol_induced_subtree(ott_ids = ott_in_tree)  # Generate a phylogenetic tree including all species present in the taxonomy

is.binary(phylo_tree)  # Check if tree is binary 


# Plot for the phylogenetic tree
plot(phylo_tree,
     cex= 1, #font size
     label.offset =.1,
     no.margin = TRUE)

# Compute branch length
phylo_branched <- compute.brlen(phylo_tree, method = "Grafen", power = 1)  # compute branch lengths using Grafen's method

phylo_branched$tip.label <- strip_ott_ids(phylo_branched$tip.label, remove_underscores = FALSE)  # remove ott ID from species name to match it to the data set

phylo_matrix <- vcv(phylo_branched, cor = T)  # Generate variance covariance matrix to correlate species relatedness 

data <- as.data.frame(data)

# Convert species_latin to lowercase
data <- mutate(data, search_string = tolower(species_latin))

data <- left_join(data, select(taxa, search_string, unique_name, ott_id), by = "search_string")  # Join data sets

data <- data[data$unique_name %in% phylo_branched$tip.label, ]  # Check that species names are well matched with the phylogenetic tree


data$phylogeny <- data$unique_name  # Rename 'unique_name' to 'phylogeny' for the models


```

## Variance covariance matrices
```{r}
# account for sampling covariance, assuming effect size within studies are correlated with rho = 0.5
#------------------------------lnRR------------------------------#
data<- data[!is.na(data$lnRRv),] 

lnRRVCV <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

lnRRVCV2 <- metafor::vcalc(vi = lnRRv, cluster = exp2_id, obs = assay_id, data = data, rho = 0.5) # Sensitivity analysis with alternative VCV

#------------------------------lnCVR------------------------------#
data <- data[!is.na(data$lnCVRv),]
lnCVRVCV <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)
lnCVRVCV2 <- metafor::vcalc(vi = lnCVRv, cluster = exp2_id, obs = assay2_id, data = data, rho = 0.5) # Sensitivity analysis with alternative VCV

#------------------------------lnVR------------------------------#
lnVRVCV <- metafor::vcalc(vi = lnVRv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

#------------------------------SMD------------------------------#
SMDVCV <- metafor::vcalc(vi = SMDv, cluster = exp_id, obs = assay_id, data = data, rho = 0.5)

#------------------------------SMDH------------------------------#
SMDHVCV <- metafor::vcalc(vi = SMDHv, cluster = study_id, obs = assay_id, data = data, rho = 0.5)
```

# **Selection of random-effect structure**

Select the "most appropriate" structure for the subsequent statistical modelling.

The potential random effect were:

- 1) Observation (*assay_id*) - A unique id for each pairwise comparison for effect size calculation

- 2) Cohort (*exp_id*) - A unique id for each exposure group in each primary study

- 3) Study (*study_id*) - A unique id for each included primary study

- 4) Pesticide  (*pesticide*) - Each pesticide used in the primary study

- 5) Species (*species*) - Each species used in the primary study

- 6) Phylogeny (*species*) - The phylogenetic relatedness for each species in the primary studies

We start from fitting a null model without including the above random effects candidates as the default reduced model, and build upon more complex models by adding random-effects a candidate one time. We use the likelihood ratio test to compare the quality of two nested models in terms of information criteria indices (AIC, BIC, AICc). 

## Null model with no random effects (lnRR)
```{r}
# fit a null model as default model
null_mod_lnRR <- rma.mv(yi = lnRR, 
                        V = lnRRVCV, 
                        method = "ML", 
                        test = "t", 
                        data = data, 
                        sparse = TRUE ) # Use ML to compare information criteria

summary(null_mod_lnRR)

```

## Add *assay_id* as a random effect and compare with the null model (lnRR)
```{r}
mod_lnRR.assay_id <- rma.mv(yi = lnRR, 
                            V = lnRRVCV,
                            random =  ~1 | assay_id,
                            method = "ML", 
                            test = "t", 
                            data = data, 
                            sparse = T)

summary(mod_lnRR.assay_id)

anova(null_mod_lnRR,mod_lnRR.assay_id)
```

Adding *assay_id* as a random effect improved model quality

## Add *study_id* as a random effect to the above better model (that used *obs_ID* a random effect) (lnRR)
```{r}
mod_lnRR.assay_id.study_id <- rma.mv(yi = lnRR,
                                     V = lnRRVCV,
                                     random = list(~1 | study_id, 
                                                   ~1 | assay_id),
                                     method = "ML",
                                     test = "t", 
                                     data = data, 
                                     sparse = T)

summary(mod_lnRR.assay_id.study_id)

anova(mod_lnRR.assay_id,mod_lnRR.assay_id.study_id)

```

Adding study *study_id* as a random effect improved model quality

## Add *exp_id* as a random effect to the above model (that used *assay_id* and *study_id* as random effets) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.exp_id <- rma.mv(yi = lnRR,
                                            V = lnRRVCV,
                                            random = list(~1 | study_id,
                                                          ~1 | exp_id,
                                                          ~1 | assay_id),
                                            method = "ML",
                                            test = "t", 
                                            data = data,
                                            sparse = T)

summary(mod_lnRR.assay_id.study_id.exp_id)

anova(mod_lnRR.assay_id.study_id,mod_lnRR.assay_id.study_id.exp_id)

```

Adding study *exp_id* as a random effect did not improve model quality and does not explain varation in the model

## Add *species* as a random effect to the better model (that used *assay_id* and *study_id* as random effets) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species <- rma.mv(yi = lnRR,
                                             V = lnRRVCV,
                                             random = list(~1 | study_id, 
                                                           ~1 | assay_id,
                                                           ~1 | species_latin),
                                             method = "ML",
                                             test = "t", 
                                             data = data,
                                             sparse = T)

summary(mod_lnRR.assay_id.study_id.species)

anova(mod_lnRR.assay_id.study_id,mod_lnRR.assay_id.study_id.species)

i2_ml(mod_lnRR.assay_id.study_id.species)
```

Adding study *species* as a random effect did not improve model quality however is biologically relevant and thus we included in the model

## Add *phylogeny* as a random effect to the better model (that used *assay_id* , *study_id* and *species* as random effects) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species.phylogeny <- rma.mv(yi = lnRR,
                                                       V = lnRRVCV,
                                                       random = list(~1 | study_id,
                                                                     ~1 | assay_id,
                                                                     ~1 | species_latin,
                                                                     ~1 | phylogeny),
                                                       method = "ML",
                                                       test = "t", 
                                                       data = data, 
                                                       sparse = T,
                                                       R = list(phylogeny = phylo_matrix))

summary(mod_lnRR.assay_id.study_id.species.phylogeny)

fitstats(mod_lnRR.assay_id.study_id.species, mod_lnRR.assay_id.study_id.species.phylogeny)

i2_ml(mod_lnRR.assay_id.study_id.species.phylogeny)
```

Adding *phylogeny* as a random effect did not improve model quality and does not explain any varation and was thus removed from the model

## Add *pesticide* as a random effect to the above model (that used *assay_id* , *study_id*, *species* and *phylogeny* as random effects) (lnRR)
```{r}
mod_lnRR.assay_id.study_id.species.pesticide <- rma.mv(yi = lnRR,
                                                       V = lnRRVCV,
                                                       random = list(~1 | study_id,
                                                                     ~1 | assay_id,
                                                                     ~1 | species_latin,
                                                                     ~1 | pesticide),
                                                       method = "ML",
                                                       test = "t", 
                                                       data = data, 
                                                       sparse = T)

summary(mod_lnRR.assay_id.study_id.species.pesticide)

anova(mod_lnRR.assay_id.study_id.species, mod_lnRR.assay_id.study_id.species.pesticide)

i2_ml(mod_lnRR.assay_id.study_id.species.pesticide)
```

Adding *pesticide* as a random effect did not improve model quality but explains varation in the dataset 

## Null model with no random effects (lnCVR)
```{r}
# fit a null model as default model
null_mod_lnCVR <- rma.mv(yi = lnCVR, 
                         V = lnCVRVCV, 
                         method = "ML", 
                         test = "t", 
                         data = data, 
                         sparse = TRUE ) # Use ML to compare information criteria

summary(null_mod_lnCVR)

```

## Add *assay_id* as a random effect and compare with the null model (lnCVR)
```{r}
mod_lnCVR.assay_id <- rma.mv(yi = lnCVR, 
                             V = lnCVRVCV,
                             random =  ~1 | assay_id,
                             method = "ML", 
                             test = "t", 
                             data = data, 
                             sparse = T)

summary(mod_lnCVR.assay_id)

anova(null_mod_lnCVR, mod_lnCVR.assay_id)

```

Adding *assay_id* as a random effect improved model quality

## Add *study_id* as a random effect to the above better model (that used *assay_id* a random effect) (lnCVR)
```{r}
mod_lnCVR.assay_id.study_id <- rma.mv(yi = lnCVR,
                                      V = lnCVRVCV,
                                      random = list(~1 | study_id, 
                                                    ~1 | assay_id),
                                      method = "ML",
                                      test = "t", 
                                      data = data, 
                                      sparse = T)

summary(mod_lnCVR.assay_id.study_id)

anova(mod_lnCVR.assay_id, mod_lnCVR.assay_id.study_id)

```

Adding *study_id* as a random effect improved model quality

## Add *exp_id* as a random effect to the above better model (that used *assay_id* and *study_id* as random effets) (lnCVR)
```{r}
mod_lnCVR.assay_id.study_id.exp_id <- rma.mv(yi = lnCVR,
                                             V = lnCVRVCV,
                                             random = list(~1 | study_id,
                                                           ~1 | exp_id,
                                                           ~1 | assay_id),
                                             method = "ML",
                                             test = "t", 
                                             data = data,
                                             sparse = T)

summary(mod_lnCVR.assay_id.study_id.exp_id)

anova(mod_lnCVR.assay_id.study_id, mod_lnCVR.assay_id.study_id.exp_id)

```

Adding *exp_id* as a random effect did not improve model quality

## Add *species* as a random effect to the above better model (that used *assay_id* and *study_id* as random effets) (lnCVR)
```{r}
mod_lnCVR.assay_id.study_id.species <- rma.mv(yi = lnCVR,
                                              V = lnCVRVCV,
                                              random = list(~1 | study_id, 
                                                            ~1 | assay_id,
                                                            ~1 | species_latin),
                                              method = "ML",
                                              test = "t", 
                                              data = data,
                                              sparse = T)

summary(mod_lnCVR.assay_id.study_id.species)

anova(mod_lnCVR.assay_id.study_id, mod_lnCVR.assay_id.study_id.species)

```

Adding study *species* as a random effect did not improve model quality however is biologically relevant and thus we included in the model

## Add *phylogeny* as a random effect to the above better model (that used *assay_id* , *study_id* and *species* as random effects) (lnCVR)
```{r}
mod_lnCVR.assay_id.study_id.species.phylogeny <- rma.mv(yi = lnCVR,
                                                        V = lnCVRVCV,
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | phylogeny),
                                                        method = "ML",
                                                        test = "t", 
                                                        data = data, 
                                                        sparse = T,
                                                        R = list(phylogeny = phylo_matrix))

summary(mod_lnCVR.assay_id.study_id.species.phylogeny)

anova(mod_lnCVR.assay_id.study_id.species, mod_lnCVR.assay_id.study_id.species.phylogeny)

```

Adding *phylogeny* as a random effect did not improve model quality however is biologically relevant and thus we included in the model

## Add *pesticide* as a random effect to the above better model (that used *assay_id* , *study_id*, *species* and *phylogeny* as random effects) (lnCVR)
```{r}
mod_lnCVR.assay_id.study_id.species.phylogeny.pesticide <- rma.mv(yi = lnCVR,
                                                                  V = lnCVRVCV,
                                                                  random = list(~1 | study_id,
                                                                                ~1 | assay_id,
                                                                                ~1 | species_latin,
                                                                                ~1 | phylogeny,
                                                                                ~1 | pesticide),
                                                                  method = "ML",
                                                                  test = "t", 
                                                                  data = data, 
                                                                  sparse = T,
                                                                  R = list(phylogeny = phylo_matrix))

summary(mod_lnCVR.assay_id.study_id.species.phylogeny.pesticide)

anova(mod_lnCVR.assay_id.study_id.species.phylogeny, mod_lnCVR.assay_id.study_id.species.phylogeny.pesticide)

```

Adding *pesticide* as a random effect did not improve model quality, and the number of levels overlaps significantly with the study.


# Intercept only meta-analysis model

## Intercept only model (lnRR)
```{r}
# Model
lnRR_intercept_only <- rma.mv(yi = lnRR,
                              V = lnRRVCV,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary statistics 
summary(lnRR_intercept_only)

mod_results(lnRR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_intercept_only)

i2_ml(lnRR_intercept_only)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = TRUE,  
             trunk.size = 4,
             branch.size = 2,
             twig.size = 1) 
```

## Intercept only model (lnCVR)
```{r}
# Model
lnCVR_intercept_only <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)
  

# Summary results
summary(lnCVR_intercept_only)

mod_results(lnCVR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnCVR_intercept_only)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_intercept_only,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE,
             trunk.size = 4,
             branch.size = 2,
             twig.size = 1) 
```

# **Single moderator meta-regression**

##  *Moderate by behaviour class (lnRR)*
```{r}
# Model
lnRR_mod_behaviour_class <- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)


# Summary results
summary(lnRR_mod_behaviour_class)

mod_results(lnRR_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_behaviour_class,
             group = "species_latin", 
             xlab = "lnRR",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = TRUE,
             fill = TRUE)
             

```

## *Moderate by behaviour class (lnCVR)*
```{r}
# Model
lnCVR_mod_behaviour_class <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary statistics
summary(lnCVR_mod_behaviour_class)

mod_results(lnCVR_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_behaviour_class)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_behaviour_class,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 

```

## Moderate by concentration of pesticide (lnRR)
```{r}
# Create dataframe for model with consistent dosage units
data_dosage_model <- data %>% 
  filter(dosage != "not reported") %>% 
filter(dosage_unit != "not reported") %>% 
filter(!dosage_unit %in% c("nm", "um", "nM")) %>%
  mutate(dosage = as.numeric(dosage),
         dosage_unit = as.character(dosage_unit),
         dosage_unit_consistent = case_when(
           dosage_unit == "mg/L" ~ "ug/L", 
           dosage_unit == "ng/L" ~ "ug/L",
           dosage_unit == "g/L" ~ "ug/L",
           dosage_unit == "ppb" ~ "ug/L", 
           dosage_unit == "ppm" ~ "ug/L", 
           TRUE ~ dosage_unit),
         dosage_convert_ugL = case_when(
           dosage_unit == "mg/L" ~ dosage * 1000,
           dosage_unit == "ng/L" ~ dosage / 1000,
           dosage_unit == "g/L" ~ dosage/1000000,
           dosage_unit == "ppm" ~ dosage*1000, 
           TRUE ~ dosage)) %>% 
   filter(!is.na(dosage_convert_ugL)) %>% 
    mutate(log_dosage_convert_ugL = log(dosage_convert_ugL)) 

# Recalculate the VCV matrix based on the new data frame 
lnRRVCV_dosage <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_dosage_model, rho = 0.5)

# Model
lnRR_mod_concentration <- rma.mv(yi = lnRR,
                               V = lnRRVCV_dosage,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~log_dosage_convert_ugL -1,
                               method = "REML",
                               test = "t", 
                               data = data_dosage_model,
                               sparse = T)

# Summary results 
summary(lnRR_mod_concentration)

dosage_mod_lnRR_results <- mod_results(lnRR_mod_concentration, mod = "log_dosage_convert_ugL", data = data_dosage_model, group = "study_id")  # For prediction intervals

r2_lnRR_duration <- r2_ml(lnRR_mod_concentration, data_dosage_model)

# Bubble plot
bubble_plot(dosage_mod_lnRR_results, mod = "log_dosage_convert_ugL", group = "study_id", data = data_dosage_model, x = "dosage_convert_ugL",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnRR_duration[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Dosage")

```

## Moderate by concentration of pesticide (lnCVR)
```{r}
# Recalculate the VCV matrix based on the new data frame 
lnCVRVCV_dosage <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data_dosage_model, rho = 0.5)

## Model
lnCVR_mod_concentration <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV_dosage,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~log_dosage_convert_ugL -1,
                               method = "REML",
                               test = "t", 
                               data = data_dosage_model,
                               sparse = T)

# Summary results
summary(lnCVR_mod_concentration)

dosage_mod_lnCVR_results <- mod_results(lnCVR_mod_concentration, mod = "log_dosage_convert_ugL", data = data_dosage_model, group = "study_id")  # For prediction intervals

r2_lnCVR_dosage <- r2_ml(lnCVR_mod_concentration, data_dosage_model)

# Bubble plot
bubble_plot(dosage_mod_lnCVR_results, mod = "log_dosage_convert_ugL", group = "study_id", data = data_dosage_model, x = "dosage_convert_ugL",
    y = "lnCVR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnCVR_dosage[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Dosage")

```

## Moderate by duration of pesticide (lnRR)
```{r}
# Create dataframe for model with consistent duration units
data_duration_model <- data %>% 
  filter(!is.na(duration), duration != "not reported") %>%
  mutate(duration = as.numeric(duration),
         duration_unit = as.character(duration_unit),
           duration_unit_consistent = case_when(
          duration_unit == "minutes" ~ "hours",
          duration_unit == "days" ~ "hours",
          duration_unit == "weeks" ~ "hours",
           TRUE ~ duration_unit),
 duration_convert = case_when(
    duration_unit == "minutes" ~ duration/ 60, 
    duration_unit == "days" ~ duration*24, 
    duration_unit == "weeks" ~ duration*168,
    TRUE ~ duration))


# Recalculate the VCV matrix based on the new data frame 
lnRRVCV_duration <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_duration_model, rho = 0.5)

# Model
lnRR_mod_duration <- rma.mv(yi = lnRR,
                               V = lnRRVCV_duration,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~duration_convert -1,
                               method = "REML",
                               test = "t", 
                               data = data_duration_model,
                               sparse = T)


# Summary results
summary(lnRR_mod_duration)

duration_mod_lnRR_results <- mod_results(lnRR_mod_duration, mod = "duration_convert", data = data_duration_model, group = "study_id")  # For prediction intervals

r2_lnRR_duration <- r2_ml(lnRR_mod_duration, data_duration_model)

# Bubble plot
bubble_plot(duration_mod_lnRR_results, mod = "duration_convert", group = "study_id", data = data_duration_model, x = "duration_convert",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnRR_duration[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Duration")

```

## Moderate by concentration of pesticide (lnRR)
```{r}
# Recalculate the VCV matrix based on the new data frame 
lnCVRVCV_duration <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data_duration_model, rho = 0.5)

## Model
lnCVR_mod_duration <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV_duration,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~duration_convert -1,
                               method = "REML",
                               test = "t", 
                               data =data_duration_model ,
                               sparse = T)

# Summary results
summary(lnCVR_mod_duration)

lnCVR_mod_duration_results <- mod_results(lnCVR_mod_duration, mod = "duration_convert", data = data_duration_model, group = "study_id")  # For prediction intervals

r2_lnCVR_duration <- r2_ml(lnCVR_mod_duration, data_duration_model)

# Bubble plot
bubble_plot(lnCVR_mod_duration_results, mod = "duration_convert", group = "study_id", data = data_duration_model, x = "duration_convert",
    y = "lnCVR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnCVR_duration[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Duration")

```

## Moderate by species (lnRR)
```{r}
# Model
lnRR_mod_species <- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnRR_mod_species)

mod_results(lnRR_mod_species, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_species)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_species,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

## Moderate by species (lnCVR)
```{r}
## ModeL
lnCVR_mod_species <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnCVR_mod_species)

mod_results(lnCVR_mod_species, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_species)

# orchaRd plot 
orchaRd::orchard_plot(lnCVR_mod_species,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by sex (lnRR)
```{r}
# Model
lnRR_mod_sex <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex - 1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)

# Summary results 
summary(lnRR_mod_sex)

mod_results(lnRR_mod_sex, mod = "sex", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_sex)


# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_sex,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "sex",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by sex (lnCVR)
```{r}
# Model
lnCVR_mod_sex <- rma.mv(yi = lnCVR,
                        V = lnCVRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~sex -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)

# Summary results
summary(lnCVR_mod_sex)

mod_results(lnCVR_mod_sex, mod = "sex", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_sex)


# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_sex,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "sex",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by pesticide chemical class (lnRR)
```{r}
# Model
lnRR_mod_pesticide <- rma.mv(yi = lnRR,
                              V = lnRRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnRR_mod_pesticide)

mod_results(lnRR_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_pesticide)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_pesticide,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by pesticide chemical class (lnCVR)
```{r}
# Model
lnCVR_mod_pesticide <- rma.mv(yi = lnCVR,
                              V = lnCVRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnCVR_mod_pesticide)

mod_results(lnCVR_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_pesticide,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)


```

## Moderate by control solvent used (lnRR)
```{r}
# Model
lnRR_mod_solvent <- rma.mv(yi = lnRR,
                        V = lnRRVCV,
                        random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                        mods = ~control_solvent -1,
                        method = "REML",
                        test = "t", 
                        data = data,
                        sparse = T)

# Summary results
summary(lnRR_mod_solvent)

mod_results(lnRR_mod_solvent, mod = "control_solvent", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_solvent)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_solvent,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "control_solvent",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by control solvent used (lnCVR)
```{r}
# Model
lnCVR_mod_solvent <- rma.mv(yi = lnCVR,
                              V = lnCVRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~control_solvent -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnCVR_mod_solvent)

mod_results(lnCVR_mod_solvent, mod = "control_solvent", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide)

# orchaRd plot 
orchaRd::orchard_plot(lnCVR_mod_solvent,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "control_solvent",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by source of fish (lnRR)
```{r}
## ModeL
lnRR_mod_source <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~source -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T,
                          R = list(phylogeny = phylo_matrix))

# Summary results
summary(lnRR_mod_source)

mod_results(lnRR_mod_source, mod = "source", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_source)

# orchaRd plot 
orchaRd::orchard_plot(lnRR_mod_source,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "source",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

## Moderate by source of fish (lnCVR)
```{r}
## Model
lnCVR_mod_source <- rma.mv(yi = lnCVR,
                           V = lnCVRVCV,
                           random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                           mods = ~source -1,
                           method = "REML",
                           test = "t", 
                           data = data,
                           sparse = T)

# Summary results
summary(lnCVR_mod_source)

mod_results(lnCVR_mod_source, mod = "source", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_source)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_source,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "source",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

## Moderate by assay (lnRR)
```{r}
lnRR_mod_assay <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)



summary(lnRR_mod_assay)



# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_assay,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "behavioural_assay_standardised2",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

## Moderate by assay (lnCVR)
```{r}
lnCVR_mod_assay <- rma.mv(yi = lnCVR,
                          V = lnCVRVCV,
                          random = list(~1 | study_id,
                                        ~1 | assay_id,
                                        ~1 | species_latin,
                                        ~1 | pesticide),
                          mods = ~behavioural_assay_standardised2 -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(lnCVR_mod_assay)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_assay,
                      group = "study_id", 
                      xlab = "lnCVR",
                      data = data,
                      mod = "behavioural_assay_standardised2",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)
```

## Moderated by use of species
```{r}
# Calculate the total number of effect sizes per species
data <- data %>%
  group_by(species_latin) %>%
  mutate(total_effect_sizes_per_species = n()) %>%
  ungroup()

# View the first few rows of the updated dataframe
head(data)

lnRR_species_used <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~total_effect_sizes_per_species -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)



summary(lnRR_species_used)

lnRR_mod_species_used_results <- mod_results(lnRR_species_used, mod = "total_effect_sizes_per_species", data = data, group = "study_id")  # For prediction intervals

r2_lnRR_species_used <- r2_ml(lnRR_species_used, data)


# Bubble plot
bubble_plot(lnRR_mod_species_used_results, mod = "total_effect_sizes_per_species", group = "study_id", data = data, x = "total_effect_sizes_per_species",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) + annotate(geom = "text",
    x = 7, y = 6.2, label = paste0("italic(R)^{2} == ", round(r2_lnRR_species_used[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
    xlab("Effect Sizes")
```

# Publication bias


ADD DESCRIOTION OF THIS METHOD HE


## Funnel plot
```{r}

# Calculate limits to "zoom out"
xlim_range <- range(lnRR_intercept_only$yi) * c(1.8, 1.8)
ylim_range <- range(1 / lnRR_intercept_only$vi) * c(1, 1)

# Create the funnel plot with adjustments
funnel(lnRR_intercept_only,
       yaxis = "seinv",  # Inverse of standard error (precision) as the y axis
       level = c(90, 95),  # levels of statistical significance highlighted
       shade = c("white", "gray55"),  # shades for different levels of statistical significance
       legend = TRUE,  # display legend
       ylab = "Precision (1/SE)",
       xlim = xlim_range,  # set x limits
       ylim = ylim_range,  # set y limits
       col = ifelse(data$control_imputed == "No", "blue", "red"))  # imputed values in red, original values in blue


# Adding title and x-axis label for completeness
title(main = "Funnel Plot", xlab = "Effect Size (lnRR)")
```

## Time lag bias
```{r}
data$pub_year <- str_extract(data$study_id, "\\d{4}")


data$pub_year <- as.numeric(data$pub_year)


time_lag_bias_model <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~pub_year -1,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)

summary(time_lag_bias_model)


lnRR_mod_time_lag_results <- mod_results(time_lag_bias_model, mod = "pub_year", data = data, group = "study_id")  # For prediction intervals



r2_lnRR_time_lag <- r2_ml(time_lag_bias_model, data)


# Calculate R^2 value
r2_lnRR_time_lag <- r2_ml(time_lag_bias_model, data)

# Get the minimum year for x-axis limit
min_year <- min(data$pub_year, na.rm = TRUE)

# Create the bubble plot
bubble_plot(lnRR_mod_time_lag_results, mod = "pub_year", group = "study_id", data = data, x = "pub_year",
    y = "lnRR", est.lwd = 1, legend.pos = "bottom.right", k.pos = "bottom.left",
    ci.col = "red", pi.col = "black", est.col = "black", g = TRUE) +
  annotate(geom = "text",
    x = min_year + 2, y = max(data$lnRR, na.rm = TRUE) + 0.2, label = paste0("italic(R)^{2} ==", round(r2_lnRR_time_lag[1], 4)), color = "black",
    parse = TRUE, size = 4)  + 
  ggtitle("") + 
  theme(plot.title = element_text(size = 18),
    legend.position = "none", axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
    axis.text.y = element_text(size = 14), axis.text.x = element_text(size = 14)) +
  xlab("Publication Year") +
  scale_x_continuous(limits = c(min_year, max(data$pub_year, na.rm = TRUE)))



```

## Heteroscadacity check
```{r}
qplot(y = sqrt(residuals(time_lag_bias_model)^2), x = fitted(time_lag_bias_model)) + # plot sqrt(residuals^2) against fitted values
      geom_point() +
      geom_smooth(method = "lm") + # method ="lm" to generate a straight line 
      geom_hline(yintercept = 0, colour="red") 
```

## Egger's regression
```{r}
eggers_regression <- rma.mv(yi = lnRR,
                          V = lnRRVCV,
                          random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                          mods = ~sqrt(lnRRv) ,
                          method = "REML",
                          test = "t", 
                          data = data,
                          sparse = T)


summary(eggers_regression)

egger_pred <- predict.rma(eggers_regression)


data %>% mutate(fit=egger_pred$pred, 
               ci.lb=egger_pred$ci.lb,
               ci.ub=egger_pred$ci.ub,
               pr.lb=egger_pred$cr.lb,
               pr.ub=egger_pred$cr.ub) %>% 
ggplot(aes(x = sqrt(lnRRv), y = lnRR)) +
     geom_ribbon(aes(ymin = pr.lb, ymax = pr.ub, color = NULL), alpha = .1) +
     geom_ribbon(aes(ymin = ci.lb, ymax = ci.ub, color = NULL), alpha = .3) +
     geom_point(size=2,shape=21, alpha=0.7, fill=RColorBrewer::brewer.pal(n = 8, name = "Dark2")[1], col="gray25",stroke=1) +
     geom_line(aes(y = fit), size = 1.2)+  
  labs(x = "Standard error", y = "lnRR") +
  theme_bw() +
  geom_hline(yintercept = 0,linetype = 2, colour = "black",alpha=0.5)+   # horizontal line at lnRR = 0
  theme(text = element_text(size = 18, colour = "black", hjust = 0.5), # change font sizes and legend position
          legend.text=element_text(size=14),
          legend.position=c(0,0), 
          legend.justification = c(0,0),
          legend.background = element_blank(), 
          legend.direction="horizontal",
          legend.title = element_text(size=15), 
          panel.border=element_rect(colour="black", fill=NA, size=1.2))
```

# **Sensitivity Analysis** 

## *Alternative effect sizes*


ADD DESCRIPTION HERE


### Intercept only model (SMDH)
```{r}
# Model
SMDH_intercept_only <- rma.mv(yi = SMDH,
                              V = SMDHVCV,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary statistics 
summary(SMDH_intercept_only)

mod_results(SMDH_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(SMDH_intercept_only)
  
# orchaRd plot
orchaRd::orchard_plot(SMDH_intercept_only,
             group = "study_id",
             xlab = "SMDH",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnVR)
```{r}
# Model
lnVR_intercept_only <- rma.mv(yi = lnVR,
                               V = lnVRVCV,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)
  

# Summary results
summary(lnVR_intercept_only)

mod_results(lnVR_intercept_only, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnVR_intercept_only)

# orchaRd plot
orchaRd::orchard_plot(lnVR_intercept_only,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Moderate by behaviour class (SMDH)
```{r}
# Model
SMDH_mod_behaviour_class <- rma.mv(yi = SMDH,
                               V = SMDHVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)


# Summary results
summary(SMDH_mod_behaviour_class)

mod_results(SMDH_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(SMDH_mod_behaviour_class)

# orchaRd plot
orchaRd::orchard_plot(SMDH_mod_behaviour_class,
             group = "pesticide_chemical_class", 
             xlab = "SMDH",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = TRUE,
             fill = TRUE) 

```

### Moderate by behaviour class (lnVR)
```{r}
# Model
lnVR_mod_behaviour_class <- rma.mv(yi = lnVR,
                               V = lnVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary statistics
summary(lnVR_mod_behaviour_class)

mod_results(lnVR_mod_behaviour_class, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_behaviour_class)

# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_behaviour_class,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 

```

### Moderate by species (SMDH)
```{r}
# Model
SMDH_mod_species <- rma.mv(yi = SMDH,
                               V = SMDHVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(SMDH_mod_species)

mod_results(SMDH_mod_species, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(SMDH_mod_species)

# orchaRd plot
orchaRd::orchard_plot(SMDH_mod_species,
             group = "study_id", 
             xlab = "SMDH",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Moderate by species (lnVR)
```{r}
## ModeL
lnVR_mod_species <- rma.mv(yi = lnVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnVR_mod_species)

mod_results(lnVR_mod_species, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_species)

# orchaRd plot 
orchaRd::orchard_plot(lnVR_mod_species,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

### Moderate by pesticide chemical class (SMDH)
```{r}
# Model
SMDH_mod_pesticide <- rma.mv(yi = SMDH,
                              V = SMDHVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(SMDH_mod_pesticide)

mod_results(SMDH_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(SMDH_mod_pesticide)

# orchaRd plot
orchaRd::orchard_plot(SMDH_mod_pesticide,
             group = "study_id", 
             xlab = "SMDH",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

### Moderate by pesticide chemical class (lnVR)
```{r}
# Model
lnVR_mod_pesticide <- rma.mv(yi = lnVR,
                              V = lnVRVCV,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnVR_mod_pesticide)

mod_results(lnVR_mod_pesticide, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnVR_mod_pesticide)

# orchaRd plot
orchaRd::orchard_plot(lnVR_mod_pesticide,
             group = "study_id", 
             xlab = "lnVR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

## *Alternative variance-covariance matrices*

### Intercept only model (lnRR)
```{r}
# Model
lnRR_intercept_only2 <- rma.mv(yi = lnRR,
                              V = lnRRVCV2,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary statistics 
summary(lnRR_intercept_only2)

mod_results(lnRR_intercept_only2, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only2)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only2,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnCVR)
```{r}
# Model
lnCVR_intercept_only2 <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV2,
                               random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)
  

# Summary results
summary(lnCVR_intercept_only2)

mod_results(lnCVR_intercept_only2, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnCVR_intercept_only2)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_intercept_only2,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Moderate by behaviour class (lnRR)
```{r}
# Model
lnRR_mod_behaviour_class2 <- rma.mv(yi = lnRR,
                               V = lnRRVCV2,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)


# Summary results
summary(lnRR_mod_behaviour_class2)

mod_results(lnRR_mod_behaviour_class2, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class2)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_behaviour_class2,
             group = "pesticide_chemical_class", 
             xlab = "lnRR",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = TRUE,
             fill = TRUE) 

```

### Moderate by behaviour class (lnCVR)
```{r}
# Model
lnCVR_mod_behaviour_class2 <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV2,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary statistics
summary(lnCVR_mod_behaviour_class2)

mod_results(lnCVR_mod_behaviour_class2, mod = "behaviour_measured_standardised", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_behaviour_class2)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_behaviour_class2,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 

```

### Moderate by species (lnRR)
```{r}
# Model
lnRR_mod_species2 <- rma.mv(yi = lnRR,
                               V = lnRRVCV2,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnRR_mod_species2)

mod_results(lnRR_mod_species2, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_species2)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_species2,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Moderate by species (lnCVR)
```{r}
## ModeL
lnCVR_mod_species2 <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV2,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data,
                               sparse = T)

# Summary results
summary(lnCVR_mod_species2)

mod_results(lnCVR_mod_species2, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_species2)

# orchaRd plot 
orchaRd::orchard_plot(lnCVR_mod_species2,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

### Moderate by pesticide chemical class (lnRR)
```{r}
# Model
lnRR_mod_pesticide2 <- rma.mv(yi = lnRR,
                              V = lnRRVCV2,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnRR_mod_pesticide2)

mod_results(lnRR_mod_pesticide2, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_pesticide2)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_pesticide2,
             group = "study_id", 
             xlab = "lnRR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)
```

### Moderate by pesticide chemical class (lnCVR)
```{r}
# Model
lnCVR_mod_pesticide2 <- rma.mv(yi = lnCVR,
                              V = lnCVRVCV2,
                              random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~pesticide_chemical_class -1,
                              method = "REML",
                              test = "t", 
                              data = data,
                              sparse = T)

# Summary results
summary(lnCVR_mod_pesticide2)

mod_results(lnCVR_mod_pesticide2, mod = "pesticide_chemical_class", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide2)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_pesticide2,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)


```
## *Leave-one-out analysis*

### *Leave one study out*

#### Intercept only model (lnRR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_lnRR <- list()
VCV_leave_study_out_lnRR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnRRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_lnRR[[i]] <- rma.mv(yi = lnRR, V = VCV_leave_study_out_lnRR[[i]], 
                                            random = list(~1 | study_id,
                                                          ~1 | assay_id,
                                                          ~1 | species_latin,
                                                          ~1 | pesticide),
                                            method = "REML", 
                                            test = "t",
                                            data = data_study_leave,
                                            sparse = TRUE)
}

results.leave_study_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_lnRR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_study_out_lnRR_forest_plot <- ggplot(results.leave_study_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_one_study_out_lnRR_forest_plot)

results.leave_study_out_model_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Intercept only model (lnCVR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_lnCVR <- list()
VCV_leave_study_out_lnCVR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_lnCVR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnCVRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_lnCVR[[i]] <- rma.mv(yi = lnCVR, V = VCV_leave_study_out_lnCVR[[i]], 
                                             random = list(~1 | study_id,
                                                           ~1 | assay_id,
                                                           ~1 | species_latin,
                                                           ~1 | pesticide),
                                             method = "REML", 
                                             test = "t",
                                             data = data_study_leave,
                                             sparse = TRUE)
}

results.leave_study_out_model_lnCVR <- as.data.frame(cbind(
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_lnCVR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_study_out_lnCVR_forest_plot <- ggplot(results.leave_study_out_model_lnCVR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_one_study_out_lnCVR_forest_plot)

results.leave_study_out_model_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by behaviour (lnRR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_behaviour_lnRR <- list()
VCV_leave_study_out_behaviour_lnRR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_behaviour_lnRR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnRRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_behaviour_lnRR[[i]] <- rma.mv(yi = lnRR,
                               V =  VCV_leave_study_out_behaviour_lnRR[[i]],
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                              mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data_study_leave,
                               sparse = T)

}

results.leave_study_out_model_behaviour_lnRR <- as.data.frame(cbind(
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_behaviour_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_behaviour_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_behaviour_lnRR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_behaviour_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_behaviour_lnRR_forest_plot <- ggplot(results.leave_study_out_model_behaviour_lnRR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_behaviour_lnRR_forest_plot)

results.leave_study_out_model_behaviour_lnRR %>% 
  summarise(estimate = mean(lnRR), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by behaviour (lnCVR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_behaviour_lnCVR <- list()
VCV_leave_study_out_behaviour_lnCVR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_behaviour_lnCVR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnCVRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_behaviour_lnCVR[[i]] <- rma.mv(yi = data_study_leave$lnCVR,
                                                      V = VCV_leave_study_out_behaviour_lnCVR[[i]],
                                                      random = list(~1 | study_id,
                                                                    ~1 | assay_id,
                                                                    ~1 | species_latin,
                                                                    ~1 | pesticide),
                                                       mods = ~behaviour_measured_standardised -1,
                                                      method = "REML",
                                                      test = "t", 
                                                      data = data_study_leave,
                                                      sparse = TRUE)
}

results.leave_study_out_model_behaviour_lnCVR <- as.data.frame(cbind(
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_behaviour_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_behaviour_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_behaviour_lnCVR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_behaviour_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_behaviour_lnCVR_forest_plot <- ggplot(results.leave_study_out_model_behaviour_lnCVR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_behaviour_lnCVR_forest_plot)

results.leave_study_out_model_behaviour_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by species (lnRR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_species_lnRR <- list()
VCV_leave_study_out_species_lnRR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_species_lnRR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnRRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_species_lnRR[[i]] <- rma.mv(yi = data_study_leave$lnRR,
                                                     V = VCV_leave_study_out_species_lnRR[[i]],
                                                     random = list(~1 | study_id,
                                                                   ~1 | assay_id,
                                                                   ~1 | species_latin,
                                                                   ~1 | pesticide),
                                                      mods = ~species_latin -1,
                                                     method = "REML",
                                                     test = "t", 
                                                     data = data_study_leave,
                                                     sparse = TRUE)
}

results.leave_study_out_model_species_lnRR <- as.data.frame(cbind(
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_species_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_species_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_species_lnRR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_species_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_species_lnRR_forest_plot <- ggplot(results.leave_study_out_model_species_lnRR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_species_lnRR_forest_plot)

results.leave_study_out_model_species_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by species (lnCVR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_species_lnCVR <- list()
VCV_leave_study_out_species_lnCVR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_species_lnCVR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnCVRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_species_lnCVR[[i]] <- rma.mv(yi = data_study_leave$lnCVR,
                                                     V = VCV_leave_study_out_species_lnCVR[[i]],
                                                     random = list(~1 | study_id,
                                                                   ~1 | assay_id,
                                                                   ~1 | species_latin,
                                                                   ~1 | pesticide),
                                                     # mods = ~species_latin -1,
                                                     method = "REML",
                                                     test = "t", 
                                                     data = data_study_leave,
                                                     sparse = TRUE)
}

results.leave_study_out_model_species_lnCVR <- as.data.frame(cbind(
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_species_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_species_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_species_lnCVR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_species_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_species_lnCVR_forest_plot <- ggplot(results.leave_study_out_model_species_lnCVR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_species_lnCVR_forest_plot)

results.leave_study_out_model_species_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by pesticide chemical class (lnRR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_pesticide_lnRR <- list()
VCV_leave_study_out_pesticide_lnRR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_pesticide_lnRR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnRRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_pesticide_lnRR[[i]] <- rma.mv(yi = data_study_leave$lnRR,
                                                      V = VCV_leave_study_out_pesticide_lnRR[[i]],
                                                      random = list(~1 | study_id,
                                                                    ~1 | assay_id,
                                                                    ~1 | species_latin,
                                                                    ~1 | pesticide),
                                                      mods = ~pesticide_chemical_class -1,
                                                      method = "REML",
                                                      test = "t", 
                                                      data = data_study_leave,
                                                      sparse = TRUE)
}

results.leave_study_out_model_pesticide_lnRR <- as.data.frame(cbind(
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_pesticide_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_pesticide_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_pesticide_lnRR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_pesticide_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_pesticide_lnRR_forest_plot <- ggplot(results.leave_study_out_model_pesticide_lnRR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_pesticide_lnRR_forest_plot)

results.leave_study_out_model_pesticide_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by pesticide chemical class (lnCVR) leaving one study out each model
```{r}
data$leave_study <- as.factor(data$study_id)

### create a list to contain model estimates
leave_study_out_model_pesticide_lnCVR <- list()
VCV_leave_study_out_pesticide_lnCVR <- list()

### repeatedly run the multilevel model, leaving out one study at a time
for(i in 1:length(levels(data$leave_study))){
  ### create the data with one study removed at a time
  data_study_leave <- data %>% filter(leave_study != levels(data$leave_study)[i])
  
  ### create a list of VCV matrices for following model fitting
  VCV_leave_study_out_pesticide_lnCVR[[i]] <- impute_covariance_matrix(vi = data_study_leave$lnCVRv, cluster = data_study_leave$study_id, r = 0.5)
  
  ### model fitting
  leave_study_out_model_pesticide_lnCVR[[i]] <- rma.mv(yi = data_study_leave$lnCVR,
                                                      V = VCV_leave_study_out_pesticide_lnCVR[[i]],
                                                      random = list(~1 | study_id,
                                                                    ~1 | assay_id,
                                                                    ~1 | species_latin,
                                                                    ~1 | pesticide),
                                                      mods = ~pesticide_chemical_class -1,
                                                      method = "REML",
                                                      test = "t", 
                                                      data = data_study_leave,
                                                      sparse = TRUE)
}

results.leave_study_out_model_pesticide_lnCVR <- as.data.frame(cbind(
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_study_out_model_pesticide_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_study_out_model_pesticide_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_study_out_model_pesticide_lnCVR$study_id <- unique(data$study_id)

# Display the results table
kable(results.leave_study_out_model_pesticide_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_study_out_model_pesticide_lnCVR_forest_plot <- ggplot(results.leave_study_out_model_pesticide_lnCVR, 
                      aes(x = fct_reorder(as.factor(study_id), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one study at a time",
       x = "Study ID",
       y = "Estimate") +
  coord_flip()

print(leave_study_out_model_pesticide_lnCVR_forest_plot)

results.leave_study_out_model_pesticide_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

### *Leave one species out*

#### Intercept only model (lnRR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_lnRR <- list()
VCV_leave_species_out_lnRR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnRRv, cluster = data_species_leave$study_id, r = 0.5)
  
    # Model fitting
    leave_species_out_model_lnRR[[i]] <- rma.mv(yi = data_species_leave$lnRR,
                                         V = VCV_leave_species_out_lnRR[[i]],
                                         random = list(~1 | study_id,
                                                       ~1 | assay_id,
                                                       ~1 | species_latin,
                                                       ~1 | pesticide),
                                         method = "REML", 
                                         test = "t",
                                         data = data_species_leave,
                                         sparse = TRUE)
} 


results.leave_species_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_species_out_model_lnRR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_species_out_lnRR_forest_plot <- ggplot(results.leave_species_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_one_species_out_lnRR_forest_plot)
```

#### Intercept only model (lnCVR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_lnCVR <- list()
VCV_leave_species_out_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_lnCVR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnCVRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_lnCVR[[i]] <- rma.mv(yi = data_species_leave$lnCVR,
                                               V = VCV_leave_species_out_lnCVR[[i]],
                                               random = list(~1 | study_id,
                                                             ~1 | assay_id,
                                                             ~1 | species_latin,
                                                             ~1 | pesticide),
                                               method = "REML", 
                                               test = "t",
                                               data = data_species_leave,
                                               sparse = TRUE)
} 

results.leave_species_out_model_lnCVR <- as.data.frame(cbind(
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_species_out_model_lnCVR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_species_out_lnCVR_forest_plot <- ggplot(results.leave_species_out_model_lnCVR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_one_species_out_lnCVR_forest_plot)


```

#### Moderate by behaviour (lnRR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_behaviour_lnRR <- list()
VCV_leave_species_out_behaviour_lnRR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_behaviour_lnRR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnRRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_behaviour_lnRR[[i]] <- rma.mv(yi = data_species_leave$lnRR,
                                                        V = VCV_leave_species_out_behaviour_lnRR[[i]],
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | pesticide),
                                                        mods = ~behaviour_measured_standardised -1,
                                                        method = "REML",
                                                        test = "t", 
                                                        data = data_species_leave,
                                                        sparse = TRUE)
}

results.leave_species_out_model_behaviour_lnRR <- as.data.frame(cbind(
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_behaviour_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_behaviour_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_species_out_model_behaviour_lnRR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_behaviour_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_species_out_model_behaviour_lnRR_forest_plot <- ggplot(results.leave_species_out_model_behaviour_lnRR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_species_out_model_behaviour_lnRR_forest_plot)

results.leave_species_out_model_behaviour_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")


```

#### Moderate by behaviour (lnCVR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_behaviour_lnCVR <- list()
VCV_leave_species_out_behaviour_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_behaviour_lnCVR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnCVRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_behaviour_lnCVR[[i]] <- rma.mv(yi = data_species_leave$lnCVR,
                                                        V = VCV_leave_species_out_behaviour_lnCVR[[i]],
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | pesticide),
                                                        mods = ~behaviour_measured_standardised -1,
                                                        method = "REML",
                                                        test = "t", 
                                                        data = data_species_leave,
                                                        sparse = TRUE)
}

results.leave_species_out_model_behaviour_lnCVR <- as.data.frame(cbind(
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_behaviour_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_behaviour_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_species_out_model_behaviour_lnCVR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_behaviour_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_species_out_model_behaviour_lnCVR_forest_plot <- ggplot(results.leave_species_out_model_behaviour_lnCVR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_species_out_model_behaviour_lnCVR_forest_plot)

results.leave_species_out_model_behaviour_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")



```

#### Moderate by pesticide chemical class (lnRR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_pesticide_lnRR <- list()
VCV_leave_species_out_pesticide_lnRR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_pesticide_lnRR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnRRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_pesticide_lnRR[[i]] <- rma.mv(yi = data_species_leave$lnRR,
                                                        V = VCV_leave_species_out_pesticide_lnRR[[i]],
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | pesticide),
                                                        mods = ~pesticide_chemical_class -1,
                                                        method = "REML",
                                                        test = "t", 
                                                        data = data_species_leave,
                                                        sparse = TRUE)
}

results.leave_species_out_model_pesticide_lnRR <- as.data.frame(cbind(
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_pesticide_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_pesticide_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_species_out_model_pesticide_lnRR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_pesticide_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_species_out_model_pesticide_lnRR_forest_plot <- ggplot(results.leave_species_out_model_pesticide_lnRR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_species_out_model_pesticide_lnRR_forest_plot)

results.leave_species_out_model_pesticide_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by pesticide chemical class (lnCVR) leaving one species out each model
```{r}
# Convert species_latin to a factor and create a new column for the leave-one-out procedure
data$leave_species <- as.factor(data$species_latin)

# Initialize lists to contain the model estimates and VCV matrices
leave_species_out_model_pesticide_lnCVR <- list()
VCV_leave_species_out_pesticide_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one species at a time
for(i in 1:length(levels(data$leave_species))){
  # Create the data with one species removed at a time
  data_species_leave <- data %>% filter(leave_species != levels(data$leave_species)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_species_out_pesticide_lnCVR[[i]] <- impute_covariance_matrix(vi = data_species_leave$lnCVRv, cluster = data_species_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_species_out_model_pesticide_lnCVR[[i]] <- rma.mv(yi = data_species_leave$lnCVR,
                                                         V = VCV_leave_species_out_pesticide_lnCVR[[i]],
                                                         random = list(~1 | study_id,
                                                                       ~1 | assay_id,
                                                                       ~1 | species_latin,
                                                                       ~1 | pesticide),
                                                         mods = ~pesticide_chemical_class -1,
                                                         method = "REML",
                                                         test = "t", 
                                                         data = data_species_leave,
                                                         sparse = TRUE)
}

results.leave_species_out_model_pesticide_lnCVR <- as.data.frame(cbind(
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_species_out_model_pesticide_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_species_out_model_pesticide_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_species_out_model_pesticide_lnCVR$species_latin <- unique(data$species_latin)

# Display the results table
kable(results.leave_species_out_model_pesticide_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_species_out_model_pesticide_lnCVR_forest_plot <- ggplot(results.leave_species_out_model_pesticide_lnCVR, 
                      aes(x = fct_reorder(as.factor(species_latin), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.5) +
  labs(caption = "The value in each point is the point estimate excluding one species at a time",
       x = "Species Latin",
       y = "Estimate") +
  coord_flip()

print(leave_species_out_model_pesticide_lnCVR_forest_plot)

results.leave_species_out_model_pesticide_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

### *Leave one pesticide out*

#### Intercept only model (lnRR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_lnRR <- list()
VCV_leave_pesticide_out_lnRR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_lnRR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnRRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_lnRR[[i]] <- rma.mv(yi = data_pesticide_leave$lnRR,
                                                V = VCV_leave_pesticide_out_lnRR[[i]],
                                                random = list(~1 | study_id,
                                                              ~1 | assay_id,
                                                              ~1 | species_latin,
                                                              ~1 | pesticide),
                                                method = "REML", 
                                                test = "t",
                                                data = data_pesticide_leave,
                                                sparse = TRUE)
} 

results.leave_pesticide_out_model_lnRR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_pesticide_out_model_lnRR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_pesticide_out_lnRR_forest_plot <- ggplot(results.leave_pesticide_out_model_lnRR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_one_pesticide_out_lnRR_forest_plot)


```

#### Intercept only model (lnCVR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_lnCVR <- list()
VCV_leave_pesticide_out_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_lnCVR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnCVRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_lnCVR[[i]] <- rma.mv(yi = data_pesticide_leave$lnCVR,
                                                V = VCV_leave_pesticide_out_lnCVR[[i]],
                                                random = list(~1 | study_id,
                                                              ~1 | assay_id,
                                                              ~1 | species_latin,
                                                              ~1 | pesticide),
                                                method = "REML", 
                                                test = "t",
                                                data = data_pesticide_leave,
                                                sparse = TRUE)
} 

results.leave_pesticide_out_model_lnCVR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub") # change column names
results.leave_pesticide_out_model_lnCVR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_one_pesticide_out_lnCVR_forest_plot <- ggplot(results.leave_pesticide_out_model_lnCVR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_one_pesticide_out_lnCVR_forest_plot)

```

#### Moderate by behaviour (lnRR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_behaviour_lnRR <- list()
VCV_leave_pesticide_out_behaviour_lnRR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_behaviour_lnRR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnRRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_behaviour_lnRR[[i]] <- rma.mv(yi = data_pesticide_leave$lnRR,
                                                          V = VCV_leave_pesticide_out_behaviour_lnRR[[i]],
                                                          random = list(~1 | study_id,
                                                                        ~1 | assay_id,
                                                                        ~1 | species_latin,
                                                                        ~1 | pesticide),
                                                          mods = ~behaviour_measured_standardised - 1,
                                                          method = "REML",
                                                          test = "t", 
                                                          data = data_pesticide_leave,
                                                          sparse = TRUE)
}

results.leave_pesticide_out_model_behaviour_lnRR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_behaviour_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_behaviour_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_pesticide_out_model_behaviour_lnRR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_behaviour_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_pesticide_out_model_behaviour_lnRR_forest_plot <- ggplot(results.leave_pesticide_out_model_behaviour_lnRR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_pesticide_out_model_behaviour_lnRR_forest_plot)

results.leave_pesticide_out_model_behaviour_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by behaviour (lnCVR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_behaviour_lnCVR <- list()
VCV_leave_pesticide_out_behaviour_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_behaviour_lnCVR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnCVRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_behaviour_lnCVR[[i]] <- rma.mv(yi = data_pesticide_leave$lnCVR,
                                                           V = VCV_leave_pesticide_out_behaviour_lnCVR[[i]],
                                                           random = list(~1 | study_id,
                                                                         ~1 | assay_id,
                                                                         ~1 | species_latin,
                                                                         ~1 | pesticide),
                                                           mods = ~behaviour_measured_standardised - 1,
                                                           method = "REML",
                                                           test = "t", 
                                                           data = data_pesticide_leave,
                                                           sparse = TRUE)
}

results.leave_pesticide_out_model_behaviour_lnCVR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_behaviour_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_behaviour_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_pesticide_out_model_behaviour_lnCVR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_behaviour_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_pesticide_out_model_behaviour_lnCVR_forest_plot <- ggplot(results.leave_pesticide_out_model_behaviour_lnCVR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_pesticide_out_model_behaviour_lnCVR_forest_plot)

results.leave_pesticide_out_model_behaviour_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by species (lnRR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_species_lnRR <- list()
VCV_leave_pesticide_out_species_lnRR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_species_lnRR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnRRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_species_lnRR[[i]] <- rma.mv(yi = data_pesticide_leave$lnRR,
                                                        V = VCV_leave_pesticide_out_species_lnRR[[i]],
                                                        random = list(~1 | study_id,
                                                                      ~1 | assay_id,
                                                                      ~1 | species_latin,
                                                                      ~1 | pesticide),
                                                        mods = ~species_latin - 1,
                                                        method = "REML",
                                                        test = "t", 
                                                        data = data_pesticide_leave,
                                                        sparse = TRUE)
}

results.leave_pesticide_out_model_species_lnRR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_species_lnRR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_species_lnRR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_pesticide_out_model_species_lnRR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_species_lnRR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_pesticide_out_model_species_lnRR_forest_plot <- ggplot(results.leave_pesticide_out_model_species_lnRR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_pesticide_out_model_species_lnRR_forest_plot)

results.leave_pesticide_out_model_species_lnRR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

#### Moderate by species (lnCVR) leaving one pesticide out each model
```{r}
# Convert pesticide_chemical_class to a factor and create a new column for the leave-one-out procedure
data$leave_pesticide <- as.factor(data$pesticide_chemical_class)

# Initialize lists to contain the model estimates and VCV matrices
leave_pesticide_out_model_species_lnCVR <- list()
VCV_leave_pesticide_out_species_lnCVR <- list()

# Iteratively run the multilevel model, leaving out one pesticide chemical class at a time
for(i in 1:length(levels(data$leave_pesticide))){
  # Create the data with one pesticide removed at a time
  data_pesticide_leave <- data %>% filter(leave_pesticide != levels(data$leave_pesticide)[i])
  
  # Create a VCV matrix for the subset data
  VCV_leave_pesticide_out_species_lnCVR[[i]] <- impute_covariance_matrix(vi = data_pesticide_leave$lnCVRv, cluster = data_pesticide_leave$study_id, r = 0.5)
  
  # Model fitting
  leave_pesticide_out_model_species_lnCVR[[i]] <- rma.mv(yi = data_pesticide_leave$lnCVR,
                                                         V = VCV_leave_pesticide_out_species_lnCVR[[i]],
                                                         random = list(~1 | study_id,
                                                                       ~1 | assay_id,
                                                                       ~1 | species_latin,
                                                                       ~1 | pesticide),
                                                         mods = ~species_latin - 1,
                                                         method = "REML",
                                                         test = "t", 
                                                         data = data_pesticide_leave,
                                                         sparse = TRUE)
}

results.leave_pesticide_out_model_species_lnCVR <- as.data.frame(cbind(
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$beta), # extract the beta coefficient from all models
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$se),   # extract the standard error from all models
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$zval), # extract the z value from all models
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$pval), # extract the p value from all models
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$ci.lb),# extract the lower confidence interval for all models
  sapply(leave_pesticide_out_model_species_lnCVR, function(x) summary(x)$ci.ub) # extract the upper confidence interval for all models
))

colnames(results.leave_pesticide_out_model_species_lnCVR) <- c("Estimate", "SE", "zval", "pval", "ci.lb", "ci.ub")
results.leave_pesticide_out_model_species_lnCVR$pesticide_chemical_class <- unique(data$pesticide_chemical_class)

# Display the results table
kable(results.leave_pesticide_out_model_species_lnCVR) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

leave_pesticide_out_model_species_lnCVR_forest_plot <- ggplot(results.leave_pesticide_out_model_species_lnCVR, 
                      aes(x = fct_reorder(as.factor(pesticide_chemical_class), Estimate), 
                          y = Estimate, 
                          ymin = ci.lb, 
                          ymax = ci.ub)) +
  geom_pointrange() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  theme_bw() +
  theme(legend.position = "none",
        axis.text = element_text(color = "black"),
        axis.title = element_text(face = "bold", color = "black"),
        plot.caption = element_text(size = 10, color = "gray10", face = "italic"),
        axis.text.y = element_text(size = 8)) +
  geom_text(aes(label = round(Estimate, 2)), size = 4, color = "gray10", nudge_x = 0.3) +
  labs(caption = "The value in each point is the estimate excluding one pesticide at a time",
       x = "Pesticide Chemical Class",
       y = "Estimate") +
  coord_flip()

print(leave_pesticide_out_model_species_lnCVR_forest_plot)

results.leave_pesticide_out_model_species_lnCVR %>% 
  summarise(estimate = mean(Estimate), # calculate the mean coefficients across the models generated
            se = mean(SE), 
            zval = mean(zval), 
            pval = mean(pval), 
            ci.lb = mean(ci.lb), 
            ci.ub = mean(ci.ub)) %>% 
  kable() %>% kable_styling("striped", position = "left")

```

## *Leave studies with imputed errors out*

### Intercept only model (lnRR) leaving out studies with imputed errors
```{r}
data_no_imputed <- data %>%  filter(data$control_imputed == "No")

lnRRVCV_no_imputed <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_no_imputed, rho = 0.5)

# Model
lnRR_intercept_only_no_imputed <- rma.mv(yi = lnRR,
                              V = lnRRVCV_no_imputed,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data_no_imputed,
                              sparse = T)

# Summary statistics 
summary(lnRR_intercept_only_no_imputed)

mod_results(lnRR_intercept_only_no_imputed, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only_no_imputed)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only_no_imputed,
             group = "study_id",
             xlab = "lnRR",
             data = data,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Intercept only model (lnCVR) leaving out studies with imputed errors
```{r}
# Calculate the variance-covariance matrix
lnCVRVCV_no_imputed <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data_no_imputed, rho = 0.5)

# Model
lnCVR_intercept_only_no_imputed <- rma.mv(yi = lnCVR,
                              V = lnCVRVCV_no_imputed,
                              random = list(~1 | study_id,
                                            ~1 | assay_id,
                                            ~1 | species_latin,
                                            ~1 | pesticide),
                              method = "REML",
                              test = "t", 
                              data = data_no_imputed,
                              sparse = T)

# Summary statistics 
summary(lnCVR_intercept_only_no_imputed)

mod_results(lnCVR_intercept_only_no_imputed, mod = "1", data = data, group = "study_id")  # For prediction intervals

i2_ml(lnCVR_intercept_only_no_imputed)
  
# orchaRd plot
orchaRd::orchard_plot(lnCVR_intercept_only_no_imputed,
             group = "study_id",
             xlab = "lnCVR",
             data = data_no_imputed,
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

### Moderate by behaviour class (lnRR) leaving out studies with imputed errors
```{r}
lnRR_mod_behaviour_class_no_imputed <- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data_no_imputed,
                               sparse = T)


# Summary results
summary(lnRR_mod_behaviour_class_no_imputed)

mod_results(lnRR_mod_behaviour_class_no_imputed, mod = "behaviour_measured_standardised", data = data_no_imputed, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_behaviour_class_no_imputed,
             group = "pesticide_chemical_class", 
             xlab = "lnRR",
             data = data_no_imputed,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = TRUE,
             fill = FALSE) 


```

### Moderate by behaviour class (lnCVR) leaving out studies with imputed errors
```{r}
lnCVR_mod_behaviour_class_no_imputed <- rma.mv(yi = lnCVR,
                               V = lnCVRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~behaviour_measured_standardised -1,
                               method = "REML",
                               test = "t", 
                               data = data_no_imputed,
                               sparse = T)

# Summary results
summary(lnCVR_mod_behaviour_class_no_imputed)

mod_results(lnCVR_mod_behaviour_class_no_imputed, mod = "behaviour_measured_standardised", data = data_no_imputed, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_behaviour_class_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_behaviour_class_no_imputed,
             group = "pesticide_chemical_class", 
             xlab = "lnCVR",
             data = data_no_imputed,
             mod = "behaviour_measured_standardised",
             k.pos = "right",
             colour = TRUE,
             fill = FALSE) 

```

### Moderate by species (lnRR) leaving out studies with imputed errors
```{r}
# Model
lnRR_mod_species_no_imputed<- rma.mv(yi = lnRR,
                               V = lnRRVCV,
                               random = list(~1 | study_id,
                                             ~1 | assay_id,
                                             ~1 | species_latin,
                                             ~1 | pesticide),
                               mods = ~species_latin -1,
                               method = "REML",
                               test = "t", 
                               data = data_no_imputed,
                               sparse = T)

# Summary results
summary(lnRR_mod_species_no_imputed)

mod_results(lnRR_mod_species_no_imputed, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_species_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_species_no_imputedlnRR_mod_species_no_imputed,
             group = "study_id", 
             xlab = "lnRR",
             data = data_no_imputed,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE) 
```

### Moderate by species (lnCVR) leaving out studies with imputed errors
```{r}
# Model
lnCVR_mod_species_no_imputed <- rma.mv(yi = lnCVR,
                                       V = lnCVRVCV2,
                                       random = list(~1 | study_id,
                                                     ~1 | assay_id,
                                                     ~1 | species_latin,
                                                     ~1 | pesticide),
                                       mods = ~species_latin -1,
                                       method = "REML",
                                       test = "t", 
                                       data = data_no_imputed,
                                       sparse = TRUE)

# Summary results
summary(lnCVR_mod_species_no_imputed)

mod_results(lnCVR_mod_species_no_imputed, mod = "species_latin", data = data, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_species_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_species_no_imputed,
             group = "study_id", 
             xlab = "lnCVR",
             data = data_no_imputeddata_no_imputed,
             mod = "species_latin",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

### Moderate by pesticide chemical class (lnRR) leaving out studies with imputed errors
```{r}
# Model
lnCVR_mod_pesticide_no_imputed <- rma.mv(yi = lnCVR,
                                         V = lnCVRVCV,
                                         random = list(~1 | study_id,
                                                       ~1 | assay_id,
                                                       ~1 | species_latin,
                                                       ~1 | pesticide),
                                         mods = ~pesticide_chemical_class -1,
                                         method = "REML",
                                         test = "t", 
                                         data = data_no_imputed,
                                         sparse = TRUE)

# Summary results
summary(lnCVR_mod_pesticide_no_imputed)

mod_results(lnCVR_mod_pesticide_no_imputed, mod = "pesticide_chemical_class", data = data_no_imputed, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_pesticide_no_imputed,
             group = "study_id", 
             xlab = "lnCVR",
             data = data,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)

```

### Moderate by pesticide chemical class (lnCVR) leaving out studies with imputed errors
```{r}
# Model
lnCVR_mod_pesticide_no_imputed <- rma.mv(yi = lnCVR,
                                         V = lnCVRVCV,
                                         random = list(~1 | study_id,
                                                       ~1 | assay_id,
                                                       ~1 | species_latin,
                                                       ~1 | pesticide),
                                         mods = ~pesticide_chemical_class -1,
                                         method = "REML",
                                         test = "t", 
                                         data = data_no_imputed,
                                         sparse = TRUE)

# Summary results
summary(lnCVR_mod_pesticide_no_imputed)

mod_results(lnCVR_mod_pesticide_no_imputed, mod = "pesticide_chemical_class", data = data_no_imputed, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide_no_imputed)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_pesticide_no_imputed,
             group = "study_id", 
             xlab = "lnCVR",
             data = data_no_imputed,
             mod = "pesticide_chemical_class",
             k.pos = "right",
             colour = FALSE,
             fill = FALSE)



```

## *Create models with only Zebrafish*

### Intercept only models (lnRR) only including studies using zebrafish
```{r}

data_zebrafish <- data %>% filter(species_english == "zebrafish")

lnRRVCV_zebrafish <- metafor::vcalc(vi = lnRRv, cluster = exp_id, obs = assay_id, data = data_zebrafish, rho = 0.5)

# Model
lnRR_intercept_only_zebrafish <- rma.mv(yi = lnRR,
                                        V = lnRRVCV_zebrafish,
                                        random = list(~1 | study_id,
                                                      ~1 | assay_id,
                                                      ~1 | species_latin,
                                                      ~1 | pesticide),
                                        method = "REML",
                                        test = "t", 
                                        data = data_zebrafish,
                                        sparse = T)

# Summary statistics 
summary(lnRR_intercept_only_zebrafish)

mod_results(lnRR_intercept_only_zebrafish, mod = "1", data = data_zebrafish, group = "study_id")  # For prediction intervals

i2_ml(lnRR_intercept_only_zebrafish)
  
# orchaRd plot
orchaRd::orchard_plot(lnRR_intercept_only_zebrafish,
                      group = "study_id",
                      xlab = "lnRR",
                      data = data_zebrafish,
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)


```

### Intercept only models (lnCVR) only including studies using zebrafish
```{r}
lnCVRVCV_zebrafish <- metafor::vcalc(vi = lnCVRv, cluster = exp_id, obs = assay_id, data = data_zebrafish, rho = 0.5)

# Model
lnCVR_intercept_only_zebrafish <- rma.mv(yi = lnCVR,
                                         V = lnCVRVCV_zebrafish,
                                         random = list(~1 | study_id,
                                                       ~1 | assay_id,
                                                       ~1 | species_latin,
                                                       ~1 | pesticide),
                                         method = "REML",
                                         test = "t", 
                                         data = data_zebrafish,
                                         sparse = T)

# Summary statistics 
summary(lnCVR_intercept_only_zebrafish)

mod_results(lnCVR_intercept_only_zebrafish, mod = "1", data = data_zebrafish, group = "study_id")  # For prediction intervals

i2_ml(lnCVR_intercept_only_zebrafish)
  
# orchaRd plot
orchaRd::orchard_plot(lnCVR_intercept_only_zebrafish,
                      group = "study_id",
                      xlab = "lnCVR",
                      data = data_zebrafish,
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)
```

### Moderate by behavioural class (lnRR) only including studies using zebrafish
```{r}
# Model
lnRR_mod_behaviour_class_zebrafish <- rma.mv(yi = lnRR,
                                             V = lnRRVCV_zebrafish,
                                             random = list(~1 | study_id,
                                                           ~1 | assay_id,
                                                           ~1 | species_latin,
                                                           ~1 | pesticide),
                                             mods = ~behaviour_measured_standardised -1,
                                             method = "REML",
                                             test = "t", 
                                             data = data_zebrafish,
                                             sparse = T)

# Summary results
summary(lnRR_mod_behaviour_class_zebrafish)

mod_results(lnRR_mod_behaviour_class_zebrafish, mod = "behaviour_measured_standardised", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_behaviour_class_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_behaviour_class_zebrafish,
                      group = "pesticide_chemical_class", 
                      xlab = "lnRR",
                      data = data_zebrafish,
                      mod = "behaviour_measured_standardised",
                      k.pos = "right",
                      colour = TRUE,
                      fill = FALSE)
```

### Moderate by behavioural class (lnCVR) only including studies using zebrafish
```{r}
# Model
lnCVR_mod_behaviour_class_zebrafish <- rma.mv(yi = lnCVR,
                                              V = lnCVRVCV_zebrafish,
                                              random = list(~1 | study_id,
                                                            ~1 | assay_id,
                                                            ~1 | species_latin,
                                                            ~1 | pesticide),
                                              mods = ~behaviour_measured_standardised -1,
                                              method = "REML",
                                              test = "t", 
                                              data = data_zebrafish,
                                              sparse = T)

# Summary results
summary(lnCVR_mod_behaviour_class_zebrafish)

mod_results(lnCVR_mod_behaviour_class_zebrafish, mod = "behaviour_measured_standardised", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_behaviour_class_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_behaviour_class_zebrafish,
                      group = "pesticide_chemical_class", 
                      xlab = "lnCVR",
                      data = data_zebrafish,
                      mod = "behaviour_measured_standardised",
                      k.pos = "right",
                      colour = TRUE,
                      fill = FALSE)
```

### Moderate by pesticide chemical class (lnRR) only including studies using zebrafish
```{r}
# Model
lnRR_mod_pesticide_zebrafish <- rma.mv(yi = lnRR,
                                       V = lnRRVCV_zebrafish,
                                       random = list(~1 | study_id,
                                                     ~1 | assay_id,
                                                     ~1 | species_latin,
                                                     ~1 | pesticide),
                                       mods = ~pesticide_chemical_class -1,
                                       method = "REML",
                                       test = "t", 
                                       data = data_zebrafish,
                                       sparse = TRUE)

# Summary results
summary(lnRR_mod_pesticide_zebrafish)

mod_results(lnRR_mod_pesticide_zebrafish, mod = "pesticide_chemical_class", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnRR_mod_pesticide_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnRR_mod_pesticide_zebrafish,
                      group = "study_id", 
                      xlab = "lnRR",
                      data = data_zebrafish,
                      mod = "pesticide_chemical_class",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)

```

### Moderate by pesticide chemcial class (lnCVR) only including studies using zebrafish
```{r}
# Model
lnCVR_mod_pesticide_zebrafish <- rma.mv(yi = lnCVR,
                                        V = lnCVRVCV_zebrafish,
                                        random = list(~1 | study_id,
                                                      ~1 | assay_id,
                                                      ~1 | species_latin,
                                                      ~1 | pesticide),
                                        mods = ~pesticide_chemical_class -1,
                                        method = "REML",
                                        test = "t", 
                                        data = data_zebrafish,
                                        sparse = TRUE)

# Summary results
summary(lnCVR_mod_pesticide_zebrafish)

mod_results(lnCVR_mod_pesticide_zebrafish, mod = "pesticide_chemical_class", data = data_zebrafish, group = "study_id")  # For prediction intervals

r2_ml(lnCVR_mod_pesticide_zebrafish)

# orchaRd plot
orchaRd::orchard_plot(lnCVR_mod_pesticide_zebrafish,
                      group = "study_id", 
                      xlab = "lnCVR",
                      data = data_zebrafish,
                      mod = "pesticide_chemical_class",
                      k.pos = "right",
                      colour = FALSE,
                      fill = FALSE)
```

```{r}
sessionInfo()
```

